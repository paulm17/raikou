import React$1 from 'react';
import * as _raikou_core from '@raikou/core';
import { RaikouTheme, RaikouStyleProp, RaikouSize, RaikouColor, ElementProps, BoxProps, CompoundStylesApiProps, StylesApiProps, RaikouSpacing, Factory, RaikouRadius, StylesRecord, RaikouShadow } from '@raikou/core';

type DataTableColumnTextAlign = 'left' | 'center' | 'right';

type DataTableColumn<T = Record<string, unknown>> = {
    /**
     * Column accessor.
     * You can use dot-notation for nested objects property drilling.
     * (i.e. `department.name` or `department.company.name`)
     */
    accessor: keyof T | (string & NonNullable<unknown>);
    /**
     * Optional column header title.
     * If not present, one will be generated by "humanizing" the provided column accessor.
     * (i.e. `firstName` -> `First name`; `user.firstName` -> `User first name`)
     */
    title?: React.ReactNode;
    /**
     * Custom cell data render function.
     * Accepts the current record and its index in `records` as arguments and returns a React node
     * (remember that a string is a valid React node too).
     */
    render?: (record: T, index: number) => React.ReactNode;
    /**
     * Column text alignment.
     * @default `left`
     */
    textAlign?: DataTableColumnTextAlign;
    /**
     * If true, column will be sortable.
     */
    sortable?: boolean;
    /**
     * Optional node providing the user with filtering options.
     * If present, a filter button will be added to the column's header. Upon clicking that button,
     * a pop-over showing the provided node will be opened.
     *
     * Alternatively, a function returning a node can be provided. The function receives props with a `close`
     * method which allows programatically closing the pop-over.
     *
     * ```tsx
     * // …
     * columns={[
     *   {
     *     accessor: 'name',
     *     filter: ({ close }) => {
     *       return <Stack>
     *         <Button onClick={() => { setFilter(undefined); close(); }}>Reset</Button>
     *       </Stack>
     *     },
     *   }
     * ]}
     * // …
     * ```
     *
     * Note: this property only takes care of rendering the node which provides the filtering options.
     * It is assumed that the actual filtering is performed somewhere in user code.
     */
    filter?: React.ReactNode | ((params: {
        close: () => void;
    }) => React.ReactNode);
    /**
     * If true, filter icon will be styled differently to indicate the filter is in effect.
     */
    filtering?: boolean;
    /**
     * Desired column width.
     */
    width?: string | number;
    /**
     * If true, column will not be visible.
     */
    hidden?: boolean;
    /**
     * If set, the column will only be visible according to the specified media query.
     * Can be a string, or a function receiving the current theme and returning a string.
     */
    visibleMediaQuery?: string | ((theme: RaikouTheme) => string);
    /**
     * Optional class name passed to the column title
     */
    titleClassName?: string;
    /**
     * Optional style passed to the column title.
     * Either a style object, or a function receiving the current theme and returning a style object.
     */
    titleStyle?: RaikouStyleProp;
    /**
     * Optional class name passed to each data cell in the column.
     * Can be a string, or a function receiving the current record and its index
     * as arguments and returning a string.
     */
    cellsClassName?: string | ((record: T, index: number) => string | undefined);
    /**
     * Optional style passed to each data cell in the column.
     * A function that receives the current record and its index as arguments and returns either
     * a style object, or a function that accepts theme and returns a style object.
     */
    cellsStyle?: (record: T, index: number) => RaikouStyleProp | undefined;
    /**
     * Optional function returning an object of custom attributes to be applied to each cell in the column.
     * Receives the current record and its index as arguments.
     * Useful for adding data attributes, handling middle-clicks, etc.
     */
    customCellAttributes?: (record: T, index: number) => Record<string, unknown>;
    /**
     * Optional column footer content.
     * If at least one column has a footer, the table will display a footer row.
     */
    footer?: React.ReactNode;
    /**
     * Optional class name passed to the column footer.
     */
    footerClassName?: string;
    /**
     * Optional style passed to the column footer.
     */
    footerStyle?: RaikouStyleProp;
} & ({
    /**
     * If true, cell content in this column will be truncated with ellipsis as needed and will not wrap
     * to multiple lines (i.e. `overflow: hidden; text-overflow: ellipsis`; `white-space: nowrap`).
     * On a column, you can either set this property or `noWrap`, but not both.
     */
    ellipsis?: boolean;
    noWrap?: never;
} | {
    ellipsis?: never;
    /**
     * If true, cell content in this column will not wrap to multiple lines (i.e. `white-space: nowrap`).
     * This is useful for columns containing long strings.
     * On a column, you can either set this property or `ellipsis`, but not both.
     */
    noWrap?: boolean;
});

type DataTableCellClickHandler<T = Record<string, unknown>> = (params: {
    /**
     * Click event.
     */
    event: React.MouseEvent;
    /**
     * Clicked record.
     */
    record: T;
    /**
     * Clicked record index.
     */
    index: number;
    /**
     * Clicked column information.
     */
    column: DataTableColumn<T>;
    /**
     * Clicked column index.
     */
    columnIndex: number;
}) => void;

type DataTableColumnGroup<T = Record<string, unknown>> = {
    /**
     * Used as the `key` prop for the created `<th />`.
     */
    id: string;
    /**
     * Component to render inside the column group header.
     */
    title?: React.ReactNode;
    /**
     * Text alignment of the column group header.
     * @default `left`
     */
    textAlign?: DataTableColumnTextAlign;
    /**
     * Columns which are part of the group.
     */
    columns: DataTableColumn<T>[];
    /**
     * Optional className to apply to the column group header.
     */
    className?: string;
    /**
     * Optional style to apply to the column group header.
     * Can be a style object or a function which receives the current theme and
     * returns a style object.
     */
    style?: RaikouStyleProp;
};

type DataTableDefaultColumnProps<T = Record<string, unknown>> = Omit<DataTableColumn<T>, 'accessor' | 'hidden' | 'visibleMediaQuery' | 'render'>;

type DataTableEmptyStateProps = {
    /**
     * Content to show when no records are available.
     * The provided content will be overlaid and centered automatically.
     * You can either provide this property or `noRecordsIcon`, but not both.
     */
    emptyState?: React.ReactNode;
    noRecordsIcon?: never;
} | {
    emptyState?: never;
    /**
     * Icon to show when no records are available.
     * The provided icon will be overlaid and centered automatically.
     * You can either provide this property or `emptyState`, but not both.
     */
    noRecordsIcon?: React.ReactNode;
};

type DataTableOuterBorderProps = {
    withTableBorder?: never;
    borderRadius?: never;
} | {
    /**
     * If true, table will have border.
     */
    withTableBorder: boolean;
    /**
     * Table border radius.
     */
    borderRadius?: RaikouSize | (string & NonNullable<unknown>) | number;
};

type DataTablePageSizeSelectorProps = {
    onRecordsPerPageChange?: never;
    recordsPerPageOptions?: never;
    recordsPerPageLabel?: never;
} | {
    /**
     * Callback fired a new page size is selected.
     * Receives new page size as argument.
     */
    onRecordsPerPageChange: (recordsPerPage: number) => void;
    /**
     * Array of page sizes (numbers) to show in records per page selector.
     */
    recordsPerPageOptions: number[];
    /**
     * Label for records per page selector.
     */
    recordsPerPageLabel?: string;
};

type DataTablePaginationProps = ({
    paginationWithEdges?: never;
    page?: never;
    onPageChange?: never;
    totalRecords?: never;
    recordsPerPage?: never;
    paginationActiveTextColor?: never;
    paginationActiveBackgroundColor?: never;
    paginationSize?: never;
    loadingText?: never;
    paginationText?: never;
    paginationWrapBreakpoint?: never;
    getPaginationControlProps?: never;
} | {
    /**
     * Whenther to show first and last page navigation buttons.
     */
    paginationWithEdges?: boolean;
    /**
     * Current page number (1-based).
     * If provided, a pagination component is shown.
     */
    page: number;
    /**
     * Callback fired after page change.
     * Receives the new page number as argument.
     */
    onPageChange: (page: number) => void;
    /**
     * Total number of records in the dataset.
     */
    totalRecords: number | undefined;
    /**
     * Number of records per page.
     */
    recordsPerPage: number;
    /**
     * Pagination component size.
     * @default `sm`
     */
    paginationSize?: RaikouSize;
    /**
     * Color applied to active page button text.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     * Defaults to white.
     */
    paginationActiveTextColor?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Color applied to active page button background.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     * Defaults to primary theme color.
     */
    paginationActiveBackgroundColor?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Text to show while records are loading.
     */
    loadingText?: string;
    /**
     * Pagination text. Defaults to ```({ from, to, totalRecords }) => `${from}-${to}/${totalRecords}`
     * ```
     */
    paginationText?: (params: {
        from: number;
        to: number;
        totalRecords: number;
    }) => React.ReactNode;
    /**
     * Pagination wrap breakpoints.
     * Below this breakpoint the content will be displayed on multiple lines,
     * above it the content will be displayed on a single line.
     * @default `sm`
     */
    paginationWrapBreakpoint?: RaikouSize | (string & NonNullable<unknown>) | number;
    /**
     * Function that returns props object for pagination control.
     * Useful for improving accessibility.
     */
    getPaginationControlProps?: (control: "first" | "last" | "previous" | "next") => Record<string, unknown>;
}) & DataTablePageSizeSelectorProps;

interface TableElementProps<Selector extends string> extends BoxProps, CompoundStylesApiProps<Omit<TableFactory, "stylesNames"> & {
    stylesNames: Selector;
}> {
}
interface TableThProps extends TableElementProps<"th">, ElementProps<"th"> {
}
interface TableTdProps extends TableElementProps<"td">, ElementProps<"td"> {
}
interface TableTrProps extends TableElementProps<"tr">, ElementProps<"tr"> {
}
interface TableTheadProps extends TableElementProps<"thead">, ElementProps<"thead"> {
}
interface TableTbodyProps extends TableElementProps<"tbody">, ElementProps<"tbody"> {
}
interface TableTfootProps extends TableElementProps<"tfoot">, ElementProps<"tfoot"> {
}
interface TableCaptionProps extends TableElementProps<"caption">, ElementProps<"caption"> {
}
declare const TableTh: _raikou_core.RaikouComponent<{
    props: TableThProps;
    ref: HTMLTableCellElement;
    stylesNames: "th";
    compound: true;
}>;
declare const TableTd: _raikou_core.RaikouComponent<{
    props: TableTdProps;
    ref: HTMLTableCellElement;
    stylesNames: "td";
    compound: true;
}>;
declare const TableTr: _raikou_core.RaikouComponent<{
    props: TableTrProps;
    ref: HTMLTableRowElement;
    stylesNames: "tr";
    compound: true;
}>;
declare const TableThead: _raikou_core.RaikouComponent<{
    props: TableTheadProps;
    ref: HTMLTableSectionElement;
    stylesNames: "thead";
    compound: true;
}>;
declare const TableTbody: _raikou_core.RaikouComponent<{
    props: TableTbodyProps;
    ref: HTMLTableSectionElement;
    stylesNames: "tbody";
    compound: true;
}>;
declare const TableTfoot: _raikou_core.RaikouComponent<{
    props: TableTfootProps;
    ref: HTMLTableSectionElement;
    stylesNames: "tfoot";
    compound: true;
}>;
declare const TableCaption: _raikou_core.RaikouComponent<{
    props: TableCaptionProps;
    ref: HTMLTableCaptionElement;
    stylesNames: "caption";
    compound: true;
}>;

interface TableDataRendererProps {
    data: TableData;
}
declare function TableDataRenderer({ data }: TableDataRendererProps): React$1.JSX.Element;
declare namespace TableDataRenderer {
    var displayName: string;
}

type TableStylesNames = "table" | "thead" | "tbody" | "tfoot" | "tr" | "th" | "td" | "caption";
type TableCssVariables = {
    table: "--table-layout" | "--table-border-color" | "--table-caption-side" | "--table-horizontal-spacing" | "--table-vertical-spacing" | "--table-striped-color" | "--table-highlight-on-hover-color";
};
interface TableData {
    head?: React$1.ReactNode[];
    body?: React$1.ReactNode[][];
    foot?: React$1.ReactNode[];
    caption?: string;
}
interface TableProps extends BoxProps, StylesApiProps<TableFactory>, ElementProps<"table"> {
    /** Value of `table-layout` style, `auto` by default */
    layout?: React$1.CSSProperties["tableLayout"];
    /** Determines on which side `Table.Caption` is displayed, `bottom` by default */
    captionSide?: "top" | "bottom";
    /** Color of table borders, key of `theme.colors` or any valid CSS color */
    borderColor?: RaikouColor;
    /** Determines whether the table should have outer border, `false` by default */
    withTableBorder?: boolean;
    /** Determines whether the table should have borders between columns, `false` by default */
    withColumnBorders?: boolean;
    /** Determines whether the table should have borders between rows, `true` by default */
    withRowBorders?: boolean;
    /** Horizontal cells spacing, key of `theme.spacing` or any valid CSS value for padding, numbers are converted to rem, default value is `xs` */
    horizontalSpacing?: RaikouSpacing;
    /** Vertical cells spacing, key of `theme.spacing` or any valid CSS value for padding, numbers are converted to rem, default value is `xs` */
    verticalSpacing?: RaikouSpacing;
    /** Determines whether every odd/even row background should be changed to `strippedColor`, if set to `true`, then `odd` value will be used, `false` by default  */
    striped?: boolean | "odd" | "even";
    /** Background color of striped rows, key of `theme.colors` or any valid CSS color */
    stripedColor?: RaikouColor;
    /** Determines whether table rows background should change to `highlightOnHoverColor` when hovered, `false` by default */
    highlightOnHover?: boolean;
    /** Background color of table rows when hovered, key of `theme.colors` or any valid CSS color */
    highlightOnHoverColor?: RaikouColor;
    /** Data that should be used to generate table, ignored if `children` prop is set */
    data?: TableData;
}
type TableFactory = Factory<{
    props: TableProps;
    ref: HTMLTableElement;
    stylesNames: TableStylesNames;
    vars: TableCssVariables;
    staticComponents: {
        Thead: typeof TableThead;
        Tbody: typeof TableTbody;
        Tfoot: typeof TableTfoot;
        Td: typeof TableTd;
        Th: typeof TableTh;
        Tr: typeof TableTr;
        Caption: typeof TableCaption;
        DataRenderer: typeof TableDataRenderer;
    };
}>;

type ScrollAreaStylesNames = "root" | "viewport" | "viewportInner" | "scrollbar" | "thumb" | "corner";
type ScrollAreaCssVariables = {
    root: "--scrollarea-scrollbar-size";
};
interface ScrollAreaProps extends BoxProps, StylesApiProps<ScrollAreaFactory>, ElementProps<"div"> {
    /** Scrollbar size, any valid CSS value for width/height, numbers are converted to rem, default value is 0.75rem */
    scrollbarSize?: number | string;
    /**
     * Defines scrollbars behavior, `hover` by default
     * - `hover` – scrollbars are visible when mouse is over the scroll area
     * - `scroll` – scrollbars are visible when the scroll area is scrolled
     * - `always` – scrollbars are always visible
     * - `never` – scrollbars are always hidden
     * - `auto` – similar to `overflow: auto` – scrollbars are always visible when the content is overflowing
     * */
    type?: "auto" | "always" | "scroll" | "hover" | "never";
    /** Scroll hide delay in ms, applicable only when type is set to `hover` or `scroll`, `1000` by default */
    scrollHideDelay?: number;
    /** Determines whether scrollbars should be offset with padding, `false` by default */
    offsetScrollbars?: boolean | "x" | "y";
    /** Assigns viewport element (scrollable container) ref */
    viewportRef?: React$1.ForwardedRef<HTMLDivElement>;
    /** Props passed down to the viewport element */
    viewportProps?: React$1.ComponentPropsWithRef<"div">;
    /** Called with current position (`x` and `y` coordinates) when viewport is scrolled */
    onScrollPositionChange?: (position: {
        x: number;
        y: number;
    }) => void;
}
type ScrollAreaFactory = Factory<{
    props: ScrollAreaProps;
    ref: HTMLDivElement;
    stylesNames: ScrollAreaStylesNames;
    vars: ScrollAreaCssVariables;
    staticComponents: {
        Autosize: typeof ScrollAreaAutosize;
    };
}>;
declare const ScrollAreaAutosize: _raikou_core.RaikouComponent<{
    props: ScrollAreaProps;
    ref: HTMLDivElement;
    stylesNames: ScrollAreaStylesNames;
    vars: ScrollAreaCssVariables;
    staticComponents: {
        Autosize: typeof ScrollAreaAutosize;
    };
}>;

type DataTableColorProps<T> = {
    /**
     * Data table text color.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    c?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Data table background color.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    backgroundColor?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Color of table borders, applied to all borders except row borders.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    borderColor?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Color of row borders.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    rowBorderColor?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Background color of striped rows.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    stripedColor?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Background color of hover-highlighted row.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    highlightOnHoverColor?: RaikouColor | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Data table row text color.
     * A function that accepts row data and returns color.
     * The returned color can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    rowColor?: (record: T, index: number) => RaikouColor | undefined | {
        light: RaikouColor;
        dark: RaikouColor;
    };
    /**
     * Data table row background color.
     * A function that accepts row data and returns background color color.
     * Can be a `RaikouColor` (key of `theme.colors` or any valid CSS color string),
     * or an object with `light` and `dark` keys and `RaikouColor` values.
     */
    rowBackgroundColor?: (record: T, index: number) => RaikouColor | undefined | {
        light: RaikouColor;
        dark: RaikouColor;
    };
};

type DataTableColumnProps<T = Record<string, unknown>> = {
    /**
     * Grouped columns.
     */
    groups: DataTableColumnGroup<T>[];
    columns?: never;
} | {
    groups?: never;
    /**
     * Visible columns.
     */
    columns: DataTableColumn<T>[];
};

type RaikouLoaderComponent = React$1.ForwardRefExoticComponent<React$1.HTMLAttributes<any> & React$1.RefAttributes<any>>;
type RaikouLoadersRecord = Partial<Record<"bars" | "dots" | "oval" | "progress" | (string & {}), RaikouLoaderComponent>>;
type RaikouLoader = keyof RaikouLoadersRecord;

type DataTableLoaderProps = {
    /**
     * Loader background blur (in pixels).
     */
    loaderBackgroundBlur?: number;
} & ({
    loaderSize?: never;
    loaderType?: never;
    loaderColor?: never;
    /**
     * Custom loader component to use instead of default one.
     */
    customLoader?: React.ReactNode;
} | {
    /**
     * Loader size.
     * @default `lg`.
     */
    loaderSize?: RaikouSize | (string & NonNullable<unknown>) | number;
    /**
     * Loader type.
     */
    loaderType?: RaikouLoader;
    /**
     * Loader color.
     */
    loaderColor?: RaikouColor;
    customLoader?: never;
});

type DataTableRowClickHandler<T = Record<string, unknown>> = (params: {
    /**
     * Click event.
     */
    event: React.MouseEvent;
    /**
     * Clicked record.
     */
    record: T;
    /**
     * Clicked record index.
     */
    index: number;
}) => void;

interface CollapseProps extends BoxProps, Omit<React$1.ComponentPropsWithoutRef<"div">, keyof BoxProps> {
    /** Opened state */
    in: boolean;
    /** Called each time transition ends */
    onTransitionEnd?: () => void;
    /** Transition duration in ms, `200` by default */
    transitionDuration?: number;
    /** Transition timing function, default value is `ease` */
    transitionTimingFunction?: string;
    /** Determines whether opacity should be animated, `true` by default */
    animateOpacity?: boolean;
}

type DataTableRowExpansionCollapseProps = Pick<CollapseProps, "animateOpacity" | "transitionDuration" | "transitionTimingFunction">;

type DataTableRowExpansionProps<T = Record<string, unknown>> = {
    /**
     * Defines when rows should expand.
     * @default `click`
     */
    trigger?: 'click' | 'always' | 'never';
    /**
     * If true, multiple rows can be expanded at the same time.
     */
    allowMultiple?: boolean;
    /**
     * Function defining which records will be initially expanded.
     * Accepts an object with `record` and `index` properties and returns a boolean specifying
     * whether the row should be expanded initially.
     * Does nothing if `trigger === 'always'`.
     */
    initiallyExpanded?: (options: {
        record: T;
        index: number;
    }) => boolean;
    /**
     * Additional properties passed to the Mantine Collapse component wrapping the custom content.
     */
    collapseProps?: DataTableRowExpansionCollapseProps;
    /**
     * An object defining the row expansion behavior in controlled mode.
     */
    expanded?: {
        /**
         * Currently expanded record IDs.
         */
        recordIds: unknown[];
        /**
         * Callback fired when expanded records change.
         * Receives an array containing the newly expanded record IDs.
         */
        onRecordIdsChange?: React.Dispatch<React.SetStateAction<any[]>> | ((recordIds: unknown[]) => void);
    };
    /**
     * Function returning the custom content to be lazily rendered for an expanded row.
     * Accepts an object with properties containing the current record, its index,
     * and a `collapse()` callback that can be used to collapse the expanded row.
     * Must return a React node.
     */
    content: (params: {
        record: T;
        index: number;
        collapse: () => void;
    }) => React.ReactNode;
};

type DataTableScrollProps = {
    /**
     * Function to call when the DataTable is scrolled.
     */
    onScroll?: (position: {
        x: number;
        y: number;
    }) => void;
    /**
     * Function to call when the DataTable is scrolled to top.
     */
    onScrollToTop?: () => void;
    /**
     * Function to call when the DataTable is scrolled to bottom.
     */
    onScrollToBottom?: () => void;
    /**
     * Function to call when the DataTable is scrolled to left.
     */
    onScrollToLeft?: () => void;
    /**
     * Function to call when the DataTable is scrolled to right.
     */
    onScrollToRight?: () => void;
};

type InlineInputStylesNames = "root" | "body" | "labelWrapper" | "label" | "description" | "error";

type InputLabelStylesNames = "label" | "required";
type InputLabelCssVariables = {
    label: "--input-asterisk-color" | "--input-label-size";
};

type InputErrorStylesNames = "error";
type InputErrorCssVariables = {
    error: "--input-error-size";
};

type InputDescriptionStylesNames = "description";
type InputDescriptionCssVariables = {
    description: "--input-description-size";
};

type InputWrapperCssVariables = InputLabelCssVariables & InputErrorCssVariables & InputDescriptionCssVariables;
type InputWrapperStylesNames = "root" | InputLabelStylesNames | InputDescriptionStylesNames | InputErrorStylesNames;
interface __InputWrapperProps {
    /** Contents of `Input.Label` component, if not set, label is not rendered. */
    label?: React$1.ReactNode;
    /** Contents of `Input.Description` component, if not set, description is not rendered. */
    description?: React$1.ReactNode;
    /** Contents of `Input.Error` component, if not set, error is not rendered. */
    error?: React$1.ReactNode;
    /** Adds required attribute to the input and a red asterisk on the right side of label, `false` by default */
    required?: boolean;
    /** Determines whether required asterisk should be rendered, overrides required prop, does not add required attribute to the input, `false` by default */
    withAsterisk?: boolean;
    /** Props passed down to the `Input.Label` component */
    labelProps?: Record<string, any>;
    /** Props passed down to the `Input.Description` component */
    descriptionProps?: Record<string, any>;
    /** Props passed down to the `InputError` component */
    errorProps?: Record<string, any>;
    /** Input container component, defaults to `React.Fragment` */
    inputContainer?: (children: React$1.ReactNode) => React$1.ReactNode;
    /** Controls order of the elements, `['label', 'description', 'input', 'error']` by default */
    inputWrapperOrder?: ("label" | "input" | "description" | "error")[];
}
interface InputWrapperProps extends __InputWrapperProps, BoxProps, StylesApiProps<InputWrapperFactory>, ElementProps<"div"> {
    __staticSelector?: string;
    /** Props passed to Styles API context, replaces Input.Wrapper props */
    __stylesApiProps?: Record<string, any>;
    /** Static id used as base to generate `aria-` attributes, by default generates random id */
    id?: string;
    /** Controls size of `Input.Label`, `Input.Description` and `Input.Error` components */
    size?: RaikouSize | (string & {});
    /** `Input.Label` root element, `'label'` by default */
    labelElement?: "label" | "div";
}
type InputWrapperFactory = Factory<{
    props: InputWrapperProps;
    ref: HTMLDivElement;
    stylesNames: InputWrapperStylesNames;
    vars: InputWrapperCssVariables;
}>;

type CheckboxGroupStylesNames = InputWrapperStylesNames;
interface CheckboxGroupProps extends Omit<InputWrapperProps, "onChange"> {
    /** `Checkbox` components */
    children: React$1.ReactNode;
    /** Controlled component value */
    value?: string[];
    /** Default value for uncontrolled component */
    defaultValue?: string[];
    /** Called when value changes */
    onChange?: (value: string[]) => void;
    /** Props passed down to the `Input.Wrapper` */
    wrapperProps?: Record<string, any>;
    /** Controls size of the `Input.Wrapper`, `'sm'` by default */
    size?: RaikouSize | (string & {});
}
declare const CheckboxGroup: _raikou_core.RaikouComponent<{
    props: CheckboxGroupProps;
    ref: HTMLDivElement;
    stylesNames: CheckboxGroupStylesNames;
}>;

type CheckboxStylesNames = "icon" | "inner" | "input" | InlineInputStylesNames;
type CheckboxCssVariables = {
    root: "--checkbox-size" | "--checkbox-radius" | "--checkbox-color" | "--checkbox-icon-color";
};
interface CheckboxProps extends BoxProps, StylesApiProps<CheckboxFactory>, ElementProps<"input", "size"> {
    /** Id used to bind input and label, if not passed, unique id will be generated instead */
    id?: string;
    /** Checkbox label */
    label?: React$1.ReactNode;
    /** Key of `theme.colors` or any valid CSS color to set input background color in checked state, `theme.primaryColor` by default */
    color?: RaikouColor;
    /** Controls size of all elements */
    size?: RaikouSize | (string & {});
    /** Key of `theme.radius` or any valid CSS value to set `border-radius,` "xl" by default */
    radius?: RaikouRadius;
    /** Props passed down to the root element */
    wrapperProps?: Record<string, any>;
    /** Position of the label relative to the input, `'right'` by default */
    labelPosition?: "left" | "right";
    /** Description displayed below the label */
    description?: React$1.ReactNode;
    /** Error displayed below the label */
    error?: React$1.ReactNode;
    /** Indeterminate state of checkbox, if set, `checked` prop is ignored */
    indeterminate?: boolean;
    /** Icon rendered when checkbox has checked or indeterminate state */
    icon?: React$1.FC<{
        indeterminate: boolean | undefined;
        className: string;
    }>;
    /** Assigns ref of the root element, can be used with `Tooltip` and other similar components */
    rootRef?: React$1.ForwardedRef<HTMLDivElement>;
    /** Key of `theme.colors` or any valid CSS color to set icon color, `theme.white` by default */
    iconColor?: RaikouColor;
}
type CheckboxFactory = Factory<{
    props: CheckboxProps;
    ref: HTMLInputElement;
    stylesNames: CheckboxStylesNames;
    vars: CheckboxCssVariables;
    staticComponents: {
        Group: typeof CheckboxGroup;
    };
}>;

type DataTableSelectionTrigger = 'cell' | 'checkbox';

type DataTableSelectionProps<T = Record<string, unknown>> = {
    selectionTrigger?: never;
    selectedRecords?: never;
    onSelectedRecordsChange?: never;
    isRecordSelectable?: never;
    getRecordSelectionCheckboxProps?: never;
    allRecordsSelectionCheckboxProps?: never;
} | {
    /**
     * Defines how selection is triggered.
     * @default 'checkbox'
     */
    selectionTrigger?: DataTableSelectionTrigger;
    /**
     * Currently-selected records.
     */
    selectedRecords?: T[];
    /**
     * Callback fired when selected records change.
     * Receives and array of selected records as argument.
     */
    onSelectedRecordsChange?: (selectedRecords: T[]) => void;
    /**
     * A function used to determine whether a certain record is selectable.
     * if the function returns false, the row selection checkbox is disabled.
     * Accepts the current recors and index as arguments and returns a boolean.
     */
    isRecordSelectable?: (record: T, index: number) => boolean;
    /**
     * A function used to determine additional props of the row selection checkbox.
     * Accepts the current record and its index as arguments and returns an object.
     */
    getRecordSelectionCheckboxProps?: (record: T, index: number) => CheckboxProps;
    /**
     * Additional props for the header checkbox that toggles selection of all records.
     */
    allRecordsSelectionCheckboxProps?: CheckboxProps;
};

type DataTableSortStatus<T = Record<string, unknown>> = {
    /**
     * Sort column accessor.
     * You can use dot-notation for nested objects property drilling
     * (i.e. `department.name` or `department.company.name`).
     */
    columnAccessor: keyof T | (string & NonNullable<unknown>);
    /**
     * Sort direction - `asc` for ascending, `desc` for descending.
     */
    direction: 'asc' | 'desc';
};

type DataTableSortProps<T = Record<string, unknown>> = {
    sortStatus?: never;
    onSortStatusChange?: never;
    sortIcons?: never;
} | {
    /**
     * Current sort status (sort column accessor & direction).
     */
    sortStatus: DataTableSortStatus<T>;
    /**
     * Callback fired after change of sort status.
     * Receives the new sort status as argument.
     */
    onSortStatusChange?: (sortStatus: DataTableSortStatus<T>) => void;
    /**
     * Custom sort icons.
     */
    sortIcons?: {
        /**
         * Icon to display when column is sorted ascending.
         * Will be rotated 180deg for descending sort
         */
        sorted: React.ReactNode;
        /**
         * Icon to display when column is not sorted.
         */
        unsorted: React.ReactNode;
    };
};

type DataTableVerticalAlign = 'top' | 'center' | 'bottom';

type DataTableProps<T = Record<string, unknown>> = {
    /**
     * Data table container class name.
     */
    className?: string;
    /**
     * Data table container style.
     * Either a style object or a function that accepts current theme and returns a style object.
     */
    style?: RaikouStyleProp;
    /**
     * Data table elements class names.
     * An object with `root`, `table`, `header`, `footer` and `pagination` keys and class names
     * as values.
     */
    classNames?: Partial<Record<"root" | "table" | "header" | "footer" | "pagination", string>>;
    /**
     * Data table elements styles.
     * An object with `root`, `table`, `header`, `footer` and `pagination` keys and
     * either style objects, or functions that accept current theme and return style objects, as values.
     */
    styles?: StylesRecord<"root" | "table" | "header" | "footer" | "pagination", RaikouStyleProp>;
    /**
     * Table height.
     * @default '100%'
     */
    height?: string | number;
    /**
     * Minimum table height.
     */
    minHeight?: string | number;
    /**
     * DataTable component shadow.
     */
    shadow?: RaikouShadow;
    /**
     * If true, the user will not be able to select text.
     */
    textSelectionDisabled?: boolean;
    /**
     * Vertical alignment for row cells.
     * @default `center`
     */
    verticalAlign?: DataTableVerticalAlign;
    /**
     * If true, will show a loader with semi-transparent background, centered over the table.
     */
    fetching?: boolean;
    /**
     * If true, the last column will be pinned to the right side of the table.
     */
    pinLastColumn?: boolean;
    /**
     * Default column props; will be merged with column props provided to each column
     */
    defaultColumnProps?: DataTableDefaultColumnProps<T>;
    /**
     * A default render function for all columns.
     * Accepts the current record, its index in `records` and the column `accessor` as
     * arguments and returns a React node (remember that a string is a valid React node too).
     */
    defaultColumnRender?: (record: T, index: number, accessor: keyof T | (string & NonNullable<unknown>)) => React.ReactNode;
    /**
     * Accessor to use as unique record key.
     * Can be a string representing a property name or a function receiving the current record
     * and returning a unique value.
     * If you're providing a string, you can use dot-notation for nested objects property drilling
     * (i.e. `department.name` or `department.company.name`).
     * @default `id`
     */
    idAccessor?: (keyof T | (string & NonNullable<unknown>)) | ((record: T) => React.Key);
    /**
     * Visible records.
     * The component will try to infer its row type from here.
     */
    records?: T[];
    /**
     * Text to show on empty state and pagination footer when no records are available.
     */
    noRecordsText?: string;
    /**
     * If true, the table will not show the header with column titles.
     */
    noHeader?: boolean;
    /**
     * Function to call when a row cell is clicked.
     * Receives an object with the current record, its index in `records`, the current column,
     * its index in `columns` and the click event as properties.
     */
    onCellClick?: DataTableCellClickHandler<T>;
    /**
     * Function to call when the user right-clicks on a row cell.
     * Receives an object with the current record, its index in `records`, the current column,
     * its index in `columns` and the click event as properties.
     */
    onCellContextMenu?: DataTableCellClickHandler<T>;
    /**
     * Function to call when a row is clicked.
     * Receives an object with the current record, its index in `records` and the click event
     * as properties.
     */
    onRowClick?: DataTableRowClickHandler<T>;
    /**
     * Function to call when the user right-clicks on a row.
     * Receives an object with the current record, its index in `records` and the click event
     * as properties.
     */
    onRowContextMenu?: DataTableRowClickHandler<T>;
    /**
     * Defines the row expansion behavior.
     */
    rowExpansion?: DataTableRowExpansionProps<T>;
    /**
     * Optional class name passed to each row.
     * Can be a string or a function receiving the current record and its index as arguments and returning a string.
     */
    rowClassName?: string | ((record: T, index: number) => string | undefined);
    /**
     * Optional style passed to each row.
     * A function receiving the current record and its index as arguments and returning either
     * a style object, or a function that accepts theme and returns a style object.
     */
    rowStyle?: (record: T, index: number) => RaikouStyleProp | undefined;
    /**
     * Optional function returning an object of custom attributes to be applied to each row in the table.
     * Receives the current record and its index as arguments.
     * Useful for adding data attributes, handling middle-clicks, etc.
     */
    customRowAttributes?: (record: T, index: number) => Record<string, unknown>;
    /**
     * Ref pointing to the scrollable viewport element.
     * Useful for imperative scrolling.
     */
    scrollViewportRef?: React.RefObject<HTMLDivElement>;
    /**
     * Additional props passed to the underlying `ScrollArea` element.
     */
    scrollAreaProps?: Omit<ScrollAreaProps, "classNames" | "styles" | "onScrollPositionChange">;
    /**
     * Ref pointing to the table body element.
     */
    bodyRef?: ((instance: HTMLTableSectionElement | null) => void) | React.RefObject<HTMLTableSectionElement>;
} & Omit<TableProps, "onScroll" | "className" | "classNames" | "style" | "styles" | "p" | "px" | "py" | "pt" | "pb" | "layout" | "captionSide" | "c" | "color" | "borderColor" | "stripedColor" | "highlightOnHoverColor" | "stickyHeader" | "stickyHeaderOffset"> & DataTableColorProps<T> & DataTableColumnProps<T> & DataTableOuterBorderProps & DataTableLoaderProps & DataTableEmptyStateProps & DataTablePaginationProps & DataTableSortProps<T> & DataTableScrollProps & DataTableSelectionProps<T>;

type WithOptionalProperty<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
type WithRequiredProperty<Type, Key extends keyof Type> = Type & {
    [Property in Key]-?: Type[Property];
};

declare function DataTable<T>({ withTableBorder, borderRadius, textSelectionDisabled, height, minHeight, shadow, verticalAlign, fetching, columns, groups, pinLastColumn, defaultColumnProps, defaultColumnRender, idAccessor, records, selectionTrigger, selectedRecords, onSelectedRecordsChange, isRecordSelectable, allRecordsSelectionCheckboxProps, getRecordSelectionCheckboxProps, sortStatus, sortIcons, onSortStatusChange, horizontalSpacing, page, onPageChange, totalRecords, recordsPerPage, onRecordsPerPageChange, recordsPerPageOptions, recordsPerPageLabel, paginationWithEdges, paginationActiveTextColor, paginationActiveBackgroundColor, paginationSize, paginationText, paginationWrapBreakpoint, getPaginationControlProps, loaderBackgroundBlur, customLoader, loaderSize, loaderType, loaderColor, loadingText, emptyState, noRecordsText, noRecordsIcon, highlightOnHover, striped, noHeader, onRowClick, onRowContextMenu, onCellClick, onCellContextMenu, onScroll, onScrollToTop, onScrollToBottom, onScrollToLeft, onScrollToRight, c, backgroundColor, borderColor, rowBorderColor, stripedColor, highlightOnHoverColor, rowColor, rowBackgroundColor, rowExpansion, rowClassName, rowStyle, customRowAttributes, scrollViewportRef: scrollViewportRefProp, scrollAreaProps, bodyRef, m, my, mx, mt, mb, ml, mr, className, classNames, style, styles, ...otherProps }: DataTableProps<T>): React$1.JSX.Element;

/**
 * Utility function that returns a humanized version of a string, e.g. "camelCase" -> "Camel Case"
 */
declare function humanize(value: string): string;
/**
 * Utility function that returns an array of values that are present in the first array but not in the second
 */
declare function differenceBy<T>(arr1: T[], arr2: T[], iteratee: (value: T) => unknown): T[];
/**
 * Utility function that returns an array of unique values from a given array
 */
declare function uniqBy<T>(arr: T[], iteratee: (value: T) => unknown): T[];
/**
 * Utility function that returns the value at a given path in an object
 */
declare function getValueAtPath<T>(obj: T, path: keyof T | (string & NonNullable<unknown>)): unknown;
/**
 * Utility function that returns the record id using idAccessor
 */
declare function getRecordId<T>(record: T, idAccessor: keyof T | (string & NonNullable<unknown>) | ((record: T) => React.Key)): unknown;

export { DataTable, type DataTableCellClickHandler, type DataTableColumn, type DataTableColumnGroup, type DataTableColumnTextAlign, type DataTableDefaultColumnProps, type DataTableEmptyStateProps, type DataTableOuterBorderProps, type DataTablePaginationProps, type DataTableProps, type DataTableRowClickHandler, type DataTableRowExpansionCollapseProps, type DataTableRowExpansionProps, type DataTableSelectionProps, type DataTableSelectionTrigger, type DataTableSortProps, type DataTableSortStatus, type DataTableVerticalAlign, type WithOptionalProperty, type WithRequiredProperty, differenceBy, getRecordId, getValueAtPath, humanize, uniqBy };
