{"version":3,"sources":["../src/index.ts","../src/Affix.tsx","../../Portal/src/Portal.tsx","../../../hooks/dist/index.mjs","../../Portal/src/OptionalPortal.tsx","css-module:./Affix.module.css#css-module"],"sourcesContent":["export { Affix } from \"./Affix\";\nexport type {\n  AffixCssVariables,\n  AffixFactory,\n  AffixProps,\n  AffixStylesNames,\n  AffixBaseProps,\n} from \"./Affix\";\n","import React from \"react\";\nimport {\n  Box,\n  BoxProps,\n  StylesApiProps,\n  factory,\n  ElementProps,\n  useProps,\n  useStyles,\n  createVarsResolver,\n  Factory,\n  getDefaultZIndex,\n  rem,\n} from \"@raikou/core\";\nimport { OptionalPortal, PortalProps } from \"../../Portal/src\";\nimport classes from \"./Affix.module.css\";\n\nexport type AffixStylesNames = \"root\";\nexport type AffixCssVariables = {\n  root:\n    | \"--affix-z-index\"\n    | \"--affix-top\"\n    | \"--affix-left\"\n    | \"--affix-bottom\"\n    | \"--affix-right\";\n};\n\nexport interface AffixBaseProps {\n  /** Root element `z-index` property, `200` by default */\n  zIndex?: string | number;\n\n  /** Determines whether component should be rendered within portal, `true` by default */\n  withinPortal?: boolean;\n\n  /** Props to pass down to the `Portal` component when `withinPortal` is set */\n  portalProps?: Omit<PortalProps, \"children\">;\n\n  /** Affix position on screen, defaults value is `{ bottom: 0, right: 0 }` */\n  position?: {\n    top?: string | number;\n    left?: string | number;\n    bottom?: string | number;\n    right?: string | number;\n  };\n}\n\nexport interface AffixProps\n  extends BoxProps,\n    StylesApiProps<AffixFactory>,\n    ElementProps<\"div\"> {\n  /** Root element `z-index` property, `200` by default */\n  zIndex?: React.CSSProperties[\"zIndex\"];\n\n  /** Determines whether component should be rendered within portal, `true` by default */\n  withinPortal?: boolean;\n\n  /** Props to pass down to the `Portal` component when `withinPortal` is set */\n  portalProps?: Omit<PortalProps, \"children\">;\n\n  /** Affix position on screen, defaults value is `{ bottom: 0, right: 0 }` */\n  position?: {\n    top?: string | number;\n    left?: string | number;\n    bottom?: string | number;\n    right?: string | number;\n  };\n}\n\nexport type AffixFactory = Factory<{\n  props: AffixProps;\n  ref: HTMLDivElement;\n  stylesNames: AffixStylesNames;\n  vars: AffixCssVariables;\n}>;\n\nconst defaultProps: Partial<AffixProps> = {\n  position: { bottom: 0, right: 0 },\n  zIndex: getDefaultZIndex(\"modal\"),\n  withinPortal: true,\n};\n\nconst varsResolver = createVarsResolver<AffixFactory>(\n  (_, { zIndex, position }) => ({\n    root: {\n      \"--affix-z-index\": zIndex?.toString(),\n      \"--affix-top\": rem(position?.top),\n      \"--affix-left\": rem(position?.left),\n      \"--affix-bottom\": rem(position?.bottom),\n      \"--affix-right\": rem(position?.right),\n    },\n  }),\n);\n\nexport const Affix = factory<AffixFactory>((_props, ref) => {\n  const props = useProps(\"Affix\", defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    portalProps,\n    zIndex,\n    withinPortal,\n    position,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<AffixFactory>({\n    name: \"Affix\",\n    classes,\n    props,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  return (\n    <OptionalPortal {...portalProps} withinPortal={withinPortal}>\n      <Box ref={ref} {...getStyles(\"root\")} {...others} />\n    </OptionalPortal>\n  );\n});\n\nAffix.displayName = \"@raikou/core/Affix\";\nAffix.classes = classes;\n","import React, { useRef, useState, forwardRef } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { useIsomorphicEffect, assignRef } from \"@raikou/hooks\";\nimport { useProps } from \"@raikou/core\";\n\nfunction createPortalNode(props: React.ComponentPropsWithoutRef<\"div\">) {\n  const node = document.createElement(\"div\");\n  node.setAttribute(\"data-portal\", \"true\");\n  // eslint-disable-next-line\n  typeof props.className === \"string\" &&\n    node.classList.add(...props.className.split(\" \"));\n  // eslint-disable-next-line\n  typeof props.style === \"object\" && Object.assign(node.style, props.style);\n  // eslint-disable-next-line\n  typeof props.id === \"string\" && node.setAttribute(\"id\", props.id);\n  return node;\n}\n\nexport interface PortalProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  /** Portal children, for example, custom modal or popover */\n  children: React.ReactNode;\n\n  /** Element inside which portal should be created, by default a new div element is created and appended to the `document.body` */\n  target?: HTMLElement | string;\n}\n\nconst defaultProps: Partial<PortalProps> = {};\n\n// @ts-ignore\nexport const Portal = forwardRef<HTMLDivElement, PortalProps>((props, ref) => {\n  const { children, target, ...others } = useProps(\n    \"Portal\",\n    defaultProps,\n    props,\n  );\n\n  const [mounted, setMounted] = useState(false);\n  const nodeRef = useRef<HTMLElement | null>(null);\n\n  useIsomorphicEffect(() => {\n    setMounted(true);\n    nodeRef.current = !target\n      ? createPortalNode(others)\n      : typeof target === \"string\"\n      ? document.querySelector(target)\n      : target;\n\n    assignRef(ref, nodeRef.current);\n\n    if (!target && nodeRef.current) {\n      document.body.appendChild(nodeRef.current);\n    }\n\n    return () => {\n      if (!target && nodeRef.current) {\n        document.body.removeChild(nodeRef.current);\n      }\n    };\n  }, [target]);\n\n  if (!mounted || !nodeRef.current) {\n    return null;\n  }\n\n  return createPortal(<>{children}</>, nodeRef.current);\n});\n\nPortal.displayName = \"@raikou/core/Portal\";\n","// src/utils/clamp/clamp.ts\nfunction clamp(value, min, max) {\n  if (min === void 0 && max === void 0) {\n    return value;\n  }\n  if (min !== void 0 && max === void 0) {\n    return Math.max(value, min);\n  }\n  if (min === void 0 && max !== void 0) {\n    return Math.min(value, max);\n  }\n  return Math.min(Math.max(value, min), max);\n}\n\n// src/utils/lower-first/lower-first.ts\nfunction lowerFirst(value) {\n  return typeof value !== \"string\" ? \"\" : value.charAt(0).toLowerCase() + value.slice(1);\n}\n\n// src/utils/random-id/random-id.ts\nfunction randomId() {\n  return `raikou-${Math.random().toString(36).slice(2, 11)}`;\n}\n\n// src/utils/range/range.ts\nfunction range(start, end) {\n  const length = end - start + 1;\n  return Array.from({ length }, (_, index) => index + start);\n}\n\n// src/utils/shallow-equal/shallow-equal.ts\nfunction shallowEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!(a instanceof Object) || !(b instanceof Object)) {\n    return false;\n  }\n  const keys = Object.keys(a);\n  const { length } = keys;\n  if (length !== Object.keys(b).length) {\n    return false;\n  }\n  for (let i = 0; i < length; i += 1) {\n    const key = keys[i];\n    if (!(key in b)) {\n      return false;\n    }\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/upper-first/upper-first.ts\nfunction upperFirst(value) {\n  return typeof value !== \"string\" ? \"\" : value.charAt(0).toUpperCase() + value.slice(1);\n}\n\n// src/use-callback-ref/use-callback-ref.ts\nimport { useRef, useEffect, useMemo } from \"react\";\nfunction useCallbackRef(callback) {\n  const callbackRef = useRef(callback);\n  useEffect(() => {\n    callbackRef.current = callback;\n  });\n  return useMemo(() => (...args) => {\n    var _a;\n    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);\n  }, []);\n}\n\n// src/use-debounced-callback/use-debounced-callback.ts\nimport { useRef as useRef2, useEffect as useEffect2, useCallback } from \"react\";\nfunction useDebounceCallback(callback, delay) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef2(0);\n  useEffect2(() => () => window.clearTimeout(debounceTimerRef.current), []);\n  return useCallback(() => {\n    window.clearTimeout(debounceTimerRef.current);\n    debounceTimerRef.current = window.setTimeout(handleCallback, delay);\n  }, [handleCallback, delay]);\n}\n\n// src/use-click-outside/use-click-outside.ts\nimport { useEffect as useEffect3, useRef as useRef3 } from \"react\";\nvar DEFAULT_EVENTS = [\"mousedown\", \"touchstart\"];\nfunction useClickOutside(handler, events, nodes) {\n  const ref = useRef3();\n  useEffect3(() => {\n    const listener = (event) => {\n      const { target } = event ?? {};\n      if (Array.isArray(nodes)) {\n        const shouldIgnore = (target == null ? void 0 : target.hasAttribute(\"data-ignore-outside-clicks\")) || !document.body.contains(target) && target.tagName !== \"HTML\";\n        const shouldTrigger = nodes.every((node) => !!node && !event.composedPath().includes(node));\n        shouldTrigger && !shouldIgnore && handler();\n      } else if (ref.current && !ref.current.contains(target)) {\n        handler();\n      }\n    };\n    (events || DEFAULT_EVENTS).forEach((fn) => document.addEventListener(fn, listener));\n    return () => {\n      (events || DEFAULT_EVENTS).forEach((fn) => document.removeEventListener(fn, listener));\n    };\n  }, [ref, handler, nodes]);\n  return ref;\n}\n\n// src/use-clipboard/use-clipboard.ts\nimport { useState } from \"react\";\nfunction useClipboard({ timeout = 2e3 } = {}) {\n  const [error, setError] = useState(null);\n  const [copied, setCopied] = useState(false);\n  const [copyTimeout, setCopyTimeout] = useState(null);\n  const handleCopyResult = (value) => {\n    window.clearTimeout(copyTimeout);\n    setCopyTimeout(window.setTimeout(() => setCopied(false), timeout));\n    setCopied(value);\n  };\n  const copy = (valueToCopy) => {\n    if (\"clipboard\" in navigator) {\n      navigator.clipboard.writeText(valueToCopy).then(() => handleCopyResult(true)).catch((err) => setError(err));\n    } else {\n      setError(new Error(\"useClipboard: navigator.clipboard is not supported\"));\n    }\n  };\n  const reset = () => {\n    setCopied(false);\n    setError(null);\n    window.clearTimeout(copyTimeout);\n  };\n  return { copy, reset, error, copied };\n}\n\n// src/use-media-query/use-media-query.ts\nimport { useState as useState2, useEffect as useEffect4, useRef as useRef4 } from \"react\";\nfunction attachMediaListener(query, callback) {\n  try {\n    query.addEventListener(\"change\", callback);\n    return () => query.removeEventListener(\"change\", callback);\n  } catch (e) {\n    query.addListener(callback);\n    return () => query.removeListener(callback);\n  }\n}\nfunction getInitialValue(query, initialValue) {\n  if (typeof initialValue === \"boolean\") {\n    return initialValue;\n  }\n  if (typeof window !== \"undefined\" && \"matchMedia\" in window) {\n    return window.matchMedia(query).matches;\n  }\n  return false;\n}\nfunction useMediaQuery(query, initialValue, { getInitialValueInEffect } = {\n  getInitialValueInEffect: true\n}) {\n  const [matches, setMatches] = useState2(\n    getInitialValueInEffect ? initialValue : getInitialValue(query, initialValue)\n  );\n  const queryRef = useRef4();\n  useEffect4(() => {\n    if (\"matchMedia\" in window) {\n      queryRef.current = window.matchMedia(query);\n      setMatches(queryRef.current.matches);\n      return attachMediaListener(queryRef.current, (event) => setMatches(event.matches));\n    }\n    return void 0;\n  }, [query]);\n  return matches;\n}\n\n// src/use-color-scheme/use-color-scheme.ts\nfunction useColorScheme(initialValue, options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", initialValue === \"dark\", options) ? \"dark\" : \"light\";\n}\n\n// src/use-counter/use-counter.ts\nimport { useState as useState3 } from \"react\";\nvar DEFAULT_OPTIONS = {\n  min: -Infinity,\n  max: Infinity\n};\nfunction useCounter(initialValue = 0, options) {\n  const { min, max } = { ...DEFAULT_OPTIONS, ...options };\n  const [count, setCount] = useState3(clamp(initialValue, min, max));\n  const increment = () => setCount((current) => clamp(current + 1, min, max));\n  const decrement = () => setCount((current) => clamp(current - 1, min, max));\n  const set = (value) => setCount(clamp(value, min, max));\n  const reset = () => setCount(clamp(initialValue, min, max));\n  return [count, { increment, decrement, set, reset }];\n}\n\n// src/use-debounced-state/use-debounced-state.ts\nimport { useEffect as useEffect5, useRef as useRef5, useState as useState4, useCallback as useCallback2 } from \"react\";\nfunction useDebouncedState(defaultValue, wait, options = { leading: false }) {\n  const [value, setValue] = useState4(defaultValue);\n  const timeoutRef = useRef5(null);\n  const leadingRef = useRef5(true);\n  const clearTimeout = () => window.clearTimeout(timeoutRef.current);\n  useEffect5(() => clearTimeout, []);\n  const debouncedSetValue = useCallback2(\n    (newValue) => {\n      clearTimeout();\n      if (leadingRef.current && options.leading) {\n        setValue(newValue);\n      } else {\n        timeoutRef.current = window.setTimeout(() => {\n          leadingRef.current = true;\n          setValue(newValue);\n        }, wait);\n      }\n      leadingRef.current = false;\n    },\n    [options.leading]\n  );\n  return [value, debouncedSetValue];\n}\n\n// src/use-debounced-value/use-debounced-value.ts\nimport { useEffect as useEffect6, useState as useState5, useRef as useRef6 } from \"react\";\nfunction useDebouncedValue(value, wait, options = { leading: false }) {\n  const [_value, setValue] = useState5(value);\n  const mountedRef = useRef6(false);\n  const timeoutRef = useRef6(null);\n  const cooldownRef = useRef6(false);\n  const cancel = () => window.clearTimeout(timeoutRef.current);\n  useEffect6(() => {\n    if (mountedRef.current) {\n      if (!cooldownRef.current && options.leading) {\n        cooldownRef.current = true;\n        setValue(value);\n      } else {\n        cancel();\n        timeoutRef.current = window.setTimeout(() => {\n          cooldownRef.current = false;\n          setValue(value);\n        }, wait);\n      }\n    }\n  }, [value, options.leading, wait]);\n  useEffect6(() => {\n    mountedRef.current = true;\n    return cancel;\n  }, []);\n  return [_value, cancel];\n}\n\n// src/use-isomorphic-effect/use-isomorphic-effect.ts\nimport { useEffect as useEffect7, useLayoutEffect } from \"react\";\nvar useIsomorphicEffect = typeof document !== \"undefined\" ? useLayoutEffect : useEffect7;\n\n// src/use-document-title/use-document-title.ts\nfunction useDocumentTitle(title) {\n  useIsomorphicEffect(() => {\n    if (typeof title === \"string\" && title.trim().length > 0) {\n      document.title = title.trim();\n    }\n  }, [title]);\n}\n\n// src/use-document-visibility/use-document-visibility.ts\nimport { useEffect as useEffect8, useState as useState6 } from \"react\";\nfunction useDocumentVisibility() {\n  const [documentVisibility, setDocumentVisibility] = useState6(\"visible\");\n  useEffect8(() => {\n    const listener = () => setDocumentVisibility(document.visibilityState);\n    document.addEventListener(\"visibilitychange\", listener);\n    return () => document.removeEventListener(\"visibilitychange\", listener);\n  }, []);\n  return documentVisibility;\n}\n\n// src/use-focus-return/use-focus-return.ts\nimport { useRef as useRef8 } from \"react\";\n\n// src/use-did-update/use-did-update.ts\nimport { useEffect as useEffect9, useRef as useRef7 } from \"react\";\nfunction useDidUpdate(fn, dependencies) {\n  const mounted = useRef7(false);\n  useEffect9(\n    () => () => {\n      mounted.current = false;\n    },\n    []\n  );\n  useEffect9(() => {\n    if (mounted.current) {\n      return fn();\n    }\n    mounted.current = true;\n    return void 0;\n  }, dependencies);\n}\n\n// src/use-focus-return/use-focus-return.ts\nfunction useFocusReturn({ opened, shouldReturnFocus = true }) {\n  const lastActiveElement = useRef8();\n  const returnFocus = () => {\n    var _a;\n    if (lastActiveElement.current && \"focus\" in lastActiveElement.current && typeof lastActiveElement.current.focus === \"function\") {\n      (_a = lastActiveElement.current) == null ? void 0 : _a.focus({ preventScroll: true });\n    }\n  };\n  useDidUpdate(() => {\n    let timeout = -1;\n    const clearFocusTimeout = (event) => {\n      if (event.key === \"Tab\") {\n        window.clearTimeout(timeout);\n      }\n    };\n    document.addEventListener(\"keydown\", clearFocusTimeout);\n    if (opened) {\n      lastActiveElement.current = document.activeElement;\n    } else if (shouldReturnFocus) {\n      timeout = window.setTimeout(returnFocus, 10);\n    }\n    return () => {\n      window.clearTimeout(timeout);\n      document.removeEventListener(\"keydown\", clearFocusTimeout);\n    };\n  }, [opened, shouldReturnFocus]);\n  return returnFocus;\n}\n\n// src/use-focus-trap/use-focus-trap.ts\nimport { useCallback as useCallback3, useEffect as useEffect10, useRef as useRef9 } from \"react\";\n\n// src/use-focus-trap/tabbable.ts\nvar TABBABLE_NODES = /input|select|textarea|button|object/;\nvar FOCUS_SELECTOR = \"a, input, select, textarea, button, object, [tabindex]\";\nfunction hidden(element) {\n  if (process.env.NODE_ENV === \"test\") {\n    return false;\n  }\n  return element.style.display === \"none\";\n}\nfunction visible(element) {\n  const isHidden = element.getAttribute(\"aria-hidden\") || element.getAttribute(\"hidden\") || element.getAttribute(\"type\") === \"hidden\";\n  if (isHidden) {\n    return false;\n  }\n  let parentElement = element;\n  while (parentElement) {\n    if (parentElement === document.body || parentElement.nodeType === 11) {\n      break;\n    }\n    if (hidden(parentElement)) {\n      return false;\n    }\n    parentElement = parentElement.parentNode;\n  }\n  return true;\n}\nfunction getElementTabIndex(element) {\n  let tabIndex = element.getAttribute(\"tabindex\");\n  if (tabIndex === null) {\n    tabIndex = void 0;\n  }\n  return parseInt(tabIndex, 10);\n}\nfunction focusable(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));\n  const res = (\n    // @ts-ignore\n    TABBABLE_NODES.test(nodeName) && !element.disabled || (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN)\n  );\n  return res && visible(element);\n}\nfunction tabbable(element) {\n  const tabIndex = getElementTabIndex(element);\n  const isTabIndexNaN = Number.isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element);\n}\nfunction findTabbableDescendants(element) {\n  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);\n}\n\n// src/use-focus-trap/scope-tab.ts\nfunction scopeTab(node, event) {\n  const tabbable2 = findTabbableDescendants(node);\n  if (!tabbable2.length) {\n    event.preventDefault();\n    return;\n  }\n  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1];\n  const root = node.getRootNode();\n  let leavingFinalTabbable = finalTabbable === root.activeElement || node === root.activeElement;\n  const activeElement = root.activeElement;\n  const activeElementIsRadio = activeElement.tagName === \"INPUT\" && activeElement.getAttribute(\"type\") === \"radio\";\n  if (activeElementIsRadio) {\n    const activeRadioGroup = tabbable2.filter(\n      (element) => element.getAttribute(\"type\") === \"radio\" && element.getAttribute(\"name\") === activeElement.getAttribute(\"name\")\n    );\n    leavingFinalTabbable = activeRadioGroup.includes(finalTabbable);\n  }\n  if (!leavingFinalTabbable) {\n    return;\n  }\n  event.preventDefault();\n  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];\n  if (target) {\n    target.focus();\n  }\n}\n\n// src/use-focus-trap/create-aria-hider.ts\nfunction createAriaHider(containerNode, selector = \"body > :not(script)\") {\n  const id = randomId();\n  const rootNodes = Array.from(\n    document.querySelectorAll(selector)\n  ).map((node) => {\n    var _a;\n    if (((_a = node == null ? void 0 : node.shadowRoot) == null ? void 0 : _a.contains(containerNode)) || node.contains(containerNode)) {\n      return void 0;\n    }\n    const ariaHidden = node.getAttribute(\"aria-hidden\");\n    const prevAriaHidden = node.getAttribute(\"data-hidden\");\n    const prevFocusId = node.getAttribute(\"data-focus-id\");\n    node.setAttribute(\"data-focus-id\", id);\n    if (ariaHidden === null || ariaHidden === \"false\") {\n      node.setAttribute(\"aria-hidden\", \"true\");\n    } else if (!prevAriaHidden && !prevFocusId) {\n      node.setAttribute(\"data-hidden\", ariaHidden);\n    }\n    return {\n      node,\n      ariaHidden: prevAriaHidden || null\n    };\n  });\n  return () => {\n    rootNodes.forEach((item) => {\n      if (!item || id !== item.node.getAttribute(\"data-focus-id\")) {\n        return;\n      }\n      if (item.ariaHidden === null) {\n        item.node.removeAttribute(\"aria-hidden\");\n      } else {\n        item.node.setAttribute(\"aria-hidden\", item.ariaHidden);\n      }\n      item.node.removeAttribute(\"data-focus-id\");\n      item.node.removeAttribute(\"data-hidden\");\n    });\n  };\n}\n\n// src/use-focus-trap/use-focus-trap.ts\nfunction useFocusTrap(active = true) {\n  const ref = useRef9();\n  const restoreAria = useRef9(null);\n  const focusNode = (node) => {\n    let focusElement = node.querySelector(\"[data-autofocus]\");\n    if (!focusElement) {\n      const children = Array.from(\n        node.querySelectorAll(FOCUS_SELECTOR)\n      );\n      focusElement = children.find(tabbable) || children.find(focusable) || null;\n      if (!focusElement && focusable(node))\n        focusElement = node;\n    }\n    if (focusElement) {\n      focusElement.focus({ preventScroll: true });\n    } else if (process.env.NODE_ENV === \"development\") {\n      console.warn(\n        \"[@raikou/hooks/use-focus-trap] Failed to find focusable element within provided node\",\n        node\n      );\n    }\n  };\n  const setRef = useCallback3(\n    (node) => {\n      if (!active) {\n        return;\n      }\n      if (node === null) {\n        if (restoreAria.current) {\n          restoreAria.current();\n          restoreAria.current = null;\n        }\n        return;\n      }\n      restoreAria.current = createAriaHider(node);\n      if (ref.current === node) {\n        return;\n      }\n      if (node) {\n        setTimeout(() => {\n          if (node.getRootNode()) {\n            focusNode(node);\n          } else if (process.env.NODE_ENV === \"development\") {\n            console.warn(\n              \"[@raikou/hooks/use-focus-trap] Ref node is not part of the dom\",\n              node\n            );\n          }\n        });\n        ref.current = node;\n      } else {\n        ref.current = null;\n      }\n    },\n    [active]\n  );\n  useEffect10(() => {\n    if (!active) {\n      return void 0;\n    }\n    ref.current && setTimeout(() => focusNode(ref.current));\n    const handleKeyDown = (event) => {\n      if (event.key === \"Tab\" && ref.current) {\n        scopeTab(ref.current, event);\n      }\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n      if (restoreAria.current) {\n        restoreAria.current();\n      }\n    };\n  }, [active]);\n  return setRef;\n}\n\n// src/use-force-update/use-force-update.ts\nimport { useReducer } from \"react\";\nvar reducer = (value) => (value + 1) % 1e6;\nfunction useForceUpdate() {\n  const [, update] = useReducer(reducer, 0);\n  return update;\n}\n\n// src/use-id/use-id.ts\nimport { useState as useState7 } from \"react\";\n\n// src/use-id/use-react-id.ts\nimport React from \"react\";\nvar __useId = React[\"useId\".toString()] || (() => void 0);\nfunction useReactId() {\n  const id = __useId();\n  return id ? `raikou-${id.replace(/:/g, \"\")}` : \"\";\n}\n\n// src/use-id/use-id.ts\nfunction useId(staticId) {\n  const reactId = useReactId();\n  const [uuid, setUuid] = useState7(reactId);\n  useIsomorphicEffect(() => {\n    setUuid(randomId());\n  }, []);\n  if (typeof staticId === \"string\") {\n    return staticId;\n  }\n  if (typeof window === \"undefined\") {\n    return reactId;\n  }\n  return uuid;\n}\n\n// src/use-idle/use-idle.ts\nimport { useState as useState8, useEffect as useEffect11, useRef as useRef10 } from \"react\";\nvar DEFAULT_EVENTS2 = [\n  \"keypress\",\n  \"mousemove\",\n  \"touchmove\",\n  \"click\",\n  \"scroll\"\n];\nvar DEFAULT_OPTIONS2 = {\n  events: DEFAULT_EVENTS2,\n  initialState: true\n};\nfunction useIdle(timeout, options) {\n  const { events, initialState } = { ...DEFAULT_OPTIONS2, ...options };\n  const [idle, setIdle] = useState8(initialState);\n  const timer = useRef10();\n  useEffect11(() => {\n    const handleEvents = () => {\n      setIdle(false);\n      if (timer.current) {\n        window.clearTimeout(timer.current);\n      }\n      timer.current = window.setTimeout(() => {\n        setIdle(true);\n      }, timeout);\n    };\n    events.forEach((event) => document.addEventListener(event, handleEvents));\n    return () => {\n      events.forEach((event) => document.removeEventListener(event, handleEvents));\n    };\n  }, [timeout]);\n  return idle;\n}\n\n// src/use-interval/use-interval.ts\nimport { useEffect as useEffect12, useRef as useRef11, useState as useState9 } from \"react\";\nfunction useInterval(fn, interval) {\n  const [active, setActive] = useState9(false);\n  const intervalRef = useRef11();\n  const fnRef = useRef11();\n  useEffect12(() => {\n    fnRef.current = fn;\n  }, [fn]);\n  const start = () => {\n    setActive((old) => {\n      if (!old && !intervalRef.current) {\n        intervalRef.current = window.setInterval(fnRef.current, interval);\n      }\n      return true;\n    });\n  };\n  const stop = () => {\n    setActive(false);\n    window.clearInterval(intervalRef.current);\n    intervalRef.current = void 0;\n  };\n  const toggle = () => {\n    if (active) {\n      stop();\n    } else {\n      start();\n    }\n  };\n  return { start, stop, toggle, active };\n}\n\n// src/use-list-state/use-list-state.ts\nimport { useState as useState10 } from \"react\";\nfunction useListState(initialValue = []) {\n  const [state, setState] = useState10(initialValue);\n  const append = (...items) => setState((current) => [...current, ...items]);\n  const prepend = (...items) => setState((current) => [...items, ...current]);\n  const insert = (index, ...items) => setState((current) => [...current.slice(0, index), ...items, ...current.slice(index)]);\n  const apply = (fn) => setState((current) => current.map((item, index) => fn(item, index)));\n  const remove = (...indices) => setState((current) => current.filter((_, index) => !indices.includes(index)));\n  const pop = () => setState((current) => {\n    const cloned = [...current];\n    cloned.pop();\n    return cloned;\n  });\n  const shift = () => setState((current) => {\n    const cloned = [...current];\n    cloned.shift();\n    return cloned;\n  });\n  const reorder = ({ from, to }) => setState((current) => {\n    const cloned = [...current];\n    const item = current[from];\n    cloned.splice(from, 1);\n    cloned.splice(to, 0, item);\n    return cloned;\n  });\n  const setItem = (index, item) => setState((current) => {\n    const cloned = [...current];\n    cloned[index] = item;\n    return cloned;\n  });\n  const setItemProp = (index, prop, value) => setState((current) => {\n    const cloned = [...current];\n    cloned[index] = { ...cloned[index], [prop]: value };\n    return cloned;\n  });\n  const applyWhere = (condition, fn) => setState(\n    (current) => current.map((item, index) => condition(item, index) ? fn(item, index) : item)\n  );\n  const filter = (fn) => {\n    setState((current) => current.filter(fn));\n  };\n  return [\n    state,\n    {\n      setState,\n      append,\n      prepend,\n      insert,\n      pop,\n      shift,\n      apply,\n      applyWhere,\n      remove,\n      reorder,\n      setItem,\n      setItemProp,\n      filter\n    }\n  ];\n}\n\n// src/use-local-storage/create-storage.ts\nimport { useState as useState11, useCallback as useCallback4, useEffect as useEffect14 } from \"react\";\n\n// src/use-window-event/use-window-event.ts\nimport { useEffect as useEffect13 } from \"react\";\nfunction useWindowEvent(type, listener, options) {\n  useEffect13(() => {\n    window.addEventListener(type, listener, options);\n    return () => window.removeEventListener(type, listener, options);\n  }, [type, listener]);\n}\n\n// src/use-local-storage/create-storage.ts\nfunction serializeJSON(value, hookName) {\n  try {\n    return JSON.stringify(value);\n  } catch (error) {\n    throw new Error(\n      `@mantine/hooks ${hookName}: Failed to serialize the value`\n    );\n  }\n}\nfunction deserializeJSON(value) {\n  try {\n    return value && JSON.parse(value);\n  } catch {\n    return value;\n  }\n}\nfunction createStorageHandler(type) {\n  const getItem = (key) => {\n    try {\n      return window[type].getItem(key);\n    } catch (error) {\n      console.warn(\n        \"use-local-storage: Failed to get value from storage, localStorage is blocked\"\n      );\n      return null;\n    }\n  };\n  const setItem = (key, value) => {\n    try {\n      window[type].setItem(key, value);\n    } catch (error) {\n      console.warn(\n        \"use-local-storage: Failed to set value to storage, localStorage is blocked\"\n      );\n    }\n  };\n  const removeItem = (key) => {\n    try {\n      window[type].removeItem(key);\n    } catch (error) {\n      console.warn(\n        \"use-local-storage: Failed to remove value from storage, localStorage is blocked\"\n      );\n    }\n  };\n  return { getItem, setItem, removeItem };\n}\nfunction createStorage(type, hookName) {\n  const eventName = type === \"localStorage\" ? \"mantine-local-storage\" : \"mantine-session-storage\";\n  const { getItem, setItem, removeItem } = createStorageHandler(type);\n  return function useStorage({\n    key,\n    defaultValue,\n    getInitialValueInEffect = true,\n    deserialize = deserializeJSON,\n    serialize = (value) => serializeJSON(value, hookName)\n  }) {\n    const readStorageValue = useCallback4(\n      (skipStorage) => {\n        if (typeof window === \"undefined\" || !(type in window) || window[type] === null || skipStorage) {\n          return defaultValue;\n        }\n        const storageValue = getItem(key);\n        return storageValue !== null ? deserialize(storageValue) : defaultValue;\n      },\n      [key, defaultValue]\n    );\n    const [value, setValue] = useState11(\n      readStorageValue(getInitialValueInEffect)\n    );\n    const setStorageValue = useCallback4(\n      (val) => {\n        if (val instanceof Function) {\n          setValue((current) => {\n            const result = val(current);\n            setItem(key, serialize(result));\n            window.dispatchEvent(\n              new CustomEvent(eventName, {\n                detail: { key, value: val(current) }\n              })\n            );\n            return result;\n          });\n        } else {\n          setItem(key, serialize(val));\n          window.dispatchEvent(\n            new CustomEvent(eventName, { detail: { key, value: val } })\n          );\n          setValue(val);\n        }\n      },\n      [key]\n    );\n    const removeStorageValue = useCallback4(() => {\n      removeItem(key);\n      window.dispatchEvent(\n        new CustomEvent(eventName, { detail: { key, value: defaultValue } })\n      );\n    }, []);\n    useWindowEvent(\"storage\", (event) => {\n      if (event.storageArea === window[type] && event.key === key) {\n        setValue(deserialize(event.newValue ?? void 0));\n      }\n    });\n    useWindowEvent(eventName, (event) => {\n      if (event.detail.key === key) {\n        setValue(event.detail.value);\n      }\n    });\n    useEffect14(() => {\n      if (defaultValue !== void 0 && value === void 0) {\n        setStorageValue(defaultValue);\n      }\n    }, [defaultValue, value, setStorageValue]);\n    useEffect14(() => {\n      if (getInitialValueInEffect) {\n        setValue(readStorageValue());\n      }\n    }, []);\n    return [\n      value === void 0 ? defaultValue : value,\n      setStorageValue,\n      removeStorageValue\n    ];\n  };\n}\n\n// src/use-local-storage/use-local-storage.ts\nfunction useLocalStorage(props) {\n  return createStorage(\"localStorage\", \"use-local-storage\")(props);\n}\n\n// src/use-session-storage/use-session-storage.ts\nfunction useSessionStorage(props) {\n  return createStorage(\"sessionStorage\", \"use-session-storage\")(props);\n}\n\n// src/use-merged-ref/use-merged-ref.ts\nimport { useCallback as useCallback5 } from \"react\";\nfunction assignRef(ref, value) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (typeof ref === \"object\" && ref !== null && \"current\" in ref) {\n    ref.current = value;\n  }\n}\nfunction mergeRefs(...refs) {\n  return (node) => {\n    refs.forEach((ref) => assignRef(ref, node));\n  };\n}\nfunction useMergedRef(...refs) {\n  return useCallback5(mergeRefs(...refs), refs);\n}\n\n// src/use-mouse/use-mouse.ts\nimport { useEffect as useEffect15, useRef as useRef12, useState as useState12 } from \"react\";\nfunction useMouse(options = { resetOnExit: false }) {\n  const [position, setPosition] = useState12({ x: 0, y: 0 });\n  const ref = useRef12();\n  const setMousePosition = (event) => {\n    if (ref.current) {\n      const rect = event.currentTarget.getBoundingClientRect();\n      const x = Math.max(\n        0,\n        Math.round(event.pageX - rect.left - (window.pageXOffset || window.scrollX))\n      );\n      const y = Math.max(\n        0,\n        Math.round(event.pageY - rect.top - (window.pageYOffset || window.scrollY))\n      );\n      setPosition({ x, y });\n    } else {\n      setPosition({ x: event.clientX, y: event.clientY });\n    }\n  };\n  const resetMousePosition = () => setPosition({ x: 0, y: 0 });\n  useEffect15(() => {\n    const element = (ref == null ? void 0 : ref.current) ? ref.current : document;\n    element.addEventListener(\"mousemove\", setMousePosition);\n    if (options.resetOnExit)\n      element.addEventListener(\"mouseleave\", resetMousePosition);\n    return () => {\n      element.removeEventListener(\"mousemove\", setMousePosition);\n      if (options.resetOnExit)\n        element.removeEventListener(\"mouseleave\", resetMousePosition);\n    };\n  }, [ref.current]);\n  return { ref, ...position };\n}\n\n// src/use-move/use-move.ts\nimport { useEffect as useEffect16, useState as useState13, useRef as useRef13 } from \"react\";\nvar clampUseMovePosition = (position) => ({\n  x: clamp(position.x, 0, 1),\n  y: clamp(position.y, 0, 1)\n});\nfunction useMove(onChange, handlers, dir = \"ltr\") {\n  const ref = useRef13();\n  const mounted = useRef13(false);\n  const isSliding = useRef13(false);\n  const frame = useRef13(0);\n  const [active, setActive] = useState13(false);\n  useEffect16(() => {\n    mounted.current = true;\n  }, []);\n  useEffect16(() => {\n    var _a, _b;\n    const onScrub = ({ x, y }) => {\n      cancelAnimationFrame(frame.current);\n      frame.current = requestAnimationFrame(() => {\n        if (mounted.current && ref.current) {\n          ref.current.style.userSelect = \"none\";\n          const rect = ref.current.getBoundingClientRect();\n          if (rect.width && rect.height) {\n            const _x = clamp((x - rect.left) / rect.width, 0, 1);\n            onChange({\n              x: dir === \"ltr\" ? _x : 1 - _x,\n              y: clamp((y - rect.top) / rect.height, 0, 1)\n            });\n          }\n        }\n      });\n    };\n    const bindEvents = () => {\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", stopScrubbing);\n      document.addEventListener(\"touchmove\", onTouchMove);\n      document.addEventListener(\"touchend\", stopScrubbing);\n    };\n    const unbindEvents = () => {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", stopScrubbing);\n      document.removeEventListener(\"touchmove\", onTouchMove);\n      document.removeEventListener(\"touchend\", stopScrubbing);\n    };\n    const startScrubbing = () => {\n      if (!isSliding.current && mounted.current) {\n        isSliding.current = true;\n        typeof (handlers == null ? void 0 : handlers.onScrubStart) === \"function\" && handlers.onScrubStart();\n        setActive(true);\n        bindEvents();\n      }\n    };\n    const stopScrubbing = () => {\n      if (isSliding.current && mounted.current) {\n        isSliding.current = false;\n        setActive(false);\n        unbindEvents();\n        setTimeout(() => {\n          typeof (handlers == null ? void 0 : handlers.onScrubEnd) === \"function\" && handlers.onScrubEnd();\n        }, 0);\n      }\n    };\n    const onMouseDown = (event) => {\n      startScrubbing();\n      event.preventDefault();\n      onMouseMove(event);\n    };\n    const onMouseMove = (event) => onScrub({ x: event.clientX, y: event.clientY });\n    const onTouchStart = (event) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      startScrubbing();\n      onTouchMove(event);\n    };\n    const onTouchMove = (event) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      onScrub({\n        x: event.changedTouches[0].clientX,\n        y: event.changedTouches[0].clientY\n      });\n    };\n    (_a = ref.current) == null ? void 0 : _a.addEventListener(\"mousedown\", onMouseDown);\n    (_b = ref.current) == null ? void 0 : _b.addEventListener(\"touchstart\", onTouchStart, {\n      passive: false\n    });\n    return () => {\n      if (ref.current) {\n        ref.current.removeEventListener(\"mousedown\", onMouseDown);\n        ref.current.removeEventListener(\"touchstart\", onTouchStart);\n      }\n    };\n  }, [dir, onChange]);\n  return { ref, active };\n}\n\n// src/use-pagination/use-pagination.ts\nimport { useMemo as useMemo2 } from \"react\";\n\n// src/use-uncontrolled/use-uncontrolled.ts\nimport { useState as useState14 } from \"react\";\nfunction useUncontrolled({\n  value,\n  defaultValue,\n  finalValue,\n  onChange = () => {\n  }\n}) {\n  const [uncontrolledValue, setUncontrolledValue] = useState14(\n    defaultValue !== void 0 ? defaultValue : finalValue\n  );\n  const handleUncontrolledChange = (val) => {\n    setUncontrolledValue(val);\n    onChange == null ? void 0 : onChange(val);\n  };\n  if (value !== void 0) {\n    return [value, onChange, true];\n  }\n  return [uncontrolledValue, handleUncontrolledChange, false];\n}\n\n// src/use-pagination/use-pagination.ts\nvar DOTS = \"dots\";\nfunction usePagination({\n  total,\n  siblings = 1,\n  boundaries = 1,\n  page,\n  initialPage = 1,\n  onChange\n}) {\n  const _total = Math.max(Math.trunc(total), 0);\n  const [activePage, setActivePage] = useUncontrolled({\n    value: page,\n    onChange,\n    defaultValue: initialPage,\n    finalValue: initialPage\n  });\n  const setPage = (pageNumber) => {\n    if (pageNumber <= 0) {\n      setActivePage(1);\n    } else if (pageNumber > _total) {\n      setActivePage(_total);\n    } else {\n      setActivePage(pageNumber);\n    }\n  };\n  const next = () => setPage(activePage + 1);\n  const previous = () => setPage(activePage - 1);\n  const first = () => setPage(1);\n  const last = () => setPage(_total);\n  const paginationRange = useMemo2(() => {\n    const totalPageNumbers = siblings * 2 + 3 + boundaries * 2;\n    if (totalPageNumbers >= _total) {\n      return range(1, _total);\n    }\n    const leftSiblingIndex = Math.max(activePage - siblings, boundaries);\n    const rightSiblingIndex = Math.min(activePage + siblings, _total - boundaries);\n    const shouldShowLeftDots = leftSiblingIndex > boundaries + 2;\n    const shouldShowRightDots = rightSiblingIndex < _total - (boundaries + 1);\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      const leftItemCount = siblings * 2 + boundaries + 2;\n      return [...range(1, leftItemCount), DOTS, ...range(_total - (boundaries - 1), _total)];\n    }\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      const rightItemCount = boundaries + 1 + 2 * siblings;\n      return [...range(1, boundaries), DOTS, ...range(_total - rightItemCount, _total)];\n    }\n    return [\n      ...range(1, boundaries),\n      DOTS,\n      ...range(leftSiblingIndex, rightSiblingIndex),\n      DOTS,\n      ...range(_total - boundaries + 1, _total)\n    ];\n  }, [_total, siblings, activePage]);\n  return {\n    range: paginationRange,\n    active: activePage,\n    setPage,\n    next,\n    previous,\n    first,\n    last\n  };\n}\n\n// src/use-queue/use-queue.ts\nimport { useState as useState15 } from \"react\";\nfunction useQueue({ initialValues = [], limit }) {\n  const [{ state, queue }, setState] = useState15({\n    state: initialValues.slice(0, limit),\n    queue: initialValues.slice(limit)\n  });\n  const add = (...items) => setState((current) => {\n    const results = [...current.state, ...current.queue, ...items];\n    return {\n      state: results.slice(0, limit),\n      queue: results.slice(limit)\n    };\n  });\n  const update = (fn) => setState((current) => {\n    const results = fn([...current.state, ...current.queue]);\n    return {\n      state: results.slice(0, limit),\n      queue: results.slice(limit)\n    };\n  });\n  const cleanQueue = () => setState((current) => ({ state: current.state, queue: [] }));\n  return {\n    state,\n    queue,\n    add,\n    update,\n    cleanQueue\n  };\n}\n\n// src/use-page-leave/use-page-leave.ts\nimport { useEffect as useEffect17 } from \"react\";\nfunction usePageLeave(onPageLeave) {\n  useEffect17(() => {\n    document.documentElement.addEventListener(\"mouseleave\", onPageLeave);\n    return () => document.documentElement.removeEventListener(\"mouseleave\", onPageLeave);\n  }, []);\n}\n\n// src/use-reduced-motion/use-reduced-motion.ts\nfunction useReducedMotion(initialValue, options) {\n  return useMediaQuery(\"(prefers-reduced-motion: reduce)\", initialValue, options);\n}\n\n// src/use-scroll-into-view/use-scroll-into-view.ts\nimport { useCallback as useCallback6, useRef as useRef14, useEffect as useEffect18 } from \"react\";\n\n// src/use-scroll-into-view/utils/ease-in-out-quad.ts\nvar easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\n// src/use-scroll-into-view/utils/get-relative-position.ts\nvar getRelativePosition = ({\n  axis,\n  target,\n  parent,\n  alignment,\n  offset,\n  isList\n}) => {\n  if (!target || !parent && typeof document === \"undefined\") {\n    return 0;\n  }\n  const isCustomParent = !!parent;\n  const parentElement = parent || document.body;\n  const parentPosition = parentElement.getBoundingClientRect();\n  const targetPosition = target.getBoundingClientRect();\n  const getDiff = (property) => targetPosition[property] - parentPosition[property];\n  if (axis === \"y\") {\n    const diff = getDiff(\"top\");\n    if (diff === 0)\n      return 0;\n    if (alignment === \"start\") {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.height * (isList ? 0 : 1) || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    const parentHeight = isCustomParent ? parentPosition.height : window.innerHeight;\n    if (alignment === \"end\") {\n      const distance = diff + offset - parentHeight + targetPosition.height;\n      const shouldScroll = distance >= -targetPosition.height * (isList ? 0 : 1) || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    if (alignment === \"center\") {\n      return diff - parentHeight / 2 + targetPosition.height / 2;\n    }\n    return 0;\n  }\n  if (axis === \"x\") {\n    const diff = getDiff(\"left\");\n    if (diff === 0)\n      return 0;\n    if (alignment === \"start\") {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.width || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    const parentWidth = isCustomParent ? parentPosition.width : window.innerWidth;\n    if (alignment === \"end\") {\n      const distance = diff + offset - parentWidth + targetPosition.width;\n      const shouldScroll = distance >= -targetPosition.width || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    if (alignment === \"center\") {\n      return diff - parentWidth / 2 + targetPosition.width / 2;\n    }\n    return 0;\n  }\n  return 0;\n};\n\n// src/use-scroll-into-view/utils/get-scroll-start.ts\nvar getScrollStart = ({ axis, parent }) => {\n  if (!parent && typeof document === \"undefined\") {\n    return 0;\n  }\n  const method = axis === \"y\" ? \"scrollTop\" : \"scrollLeft\";\n  if (parent) {\n    return parent[method];\n  }\n  const { body, documentElement } = document;\n  return body[method] + documentElement[method];\n};\n\n// src/use-scroll-into-view/utils/set-scroll-param.ts\nvar setScrollParam = ({ axis, parent, distance }) => {\n  if (!parent && typeof document === \"undefined\") {\n    return;\n  }\n  const method = axis === \"y\" ? \"scrollTop\" : \"scrollLeft\";\n  if (parent) {\n    parent[method] = distance;\n  } else {\n    const { body, documentElement } = document;\n    body[method] = distance;\n    documentElement[method] = distance;\n  }\n};\n\n// src/use-scroll-into-view/use-scroll-into-view.ts\nfunction useScrollIntoView({\n  duration = 1250,\n  axis = \"y\",\n  onScrollFinish,\n  easing = easeInOutQuad,\n  offset = 0,\n  cancelable = true,\n  isList = false\n} = {}) {\n  const frameID = useRef14(0);\n  const startTime = useRef14(0);\n  const shouldStop = useRef14(false);\n  const scrollableRef = useRef14(null);\n  const targetRef = useRef14(null);\n  const reducedMotion = useReducedMotion();\n  const cancel = () => {\n    if (frameID.current) {\n      cancelAnimationFrame(frameID.current);\n    }\n  };\n  const scrollIntoView = useCallback6(\n    ({ alignment = \"start\" } = {}) => {\n      shouldStop.current = false;\n      if (frameID.current) {\n        cancel();\n      }\n      const start = getScrollStart({ parent: scrollableRef.current, axis }) ?? 0;\n      const change = getRelativePosition({\n        parent: scrollableRef.current,\n        target: targetRef.current,\n        axis,\n        alignment,\n        offset,\n        isList\n      }) - (scrollableRef.current ? 0 : start);\n      function animateScroll() {\n        if (startTime.current === 0) {\n          startTime.current = performance.now();\n        }\n        const now = performance.now();\n        const elapsed = now - startTime.current;\n        const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;\n        const distance = start + change * easing(t);\n        setScrollParam({\n          parent: scrollableRef.current,\n          axis,\n          distance\n        });\n        if (!shouldStop.current && t < 1) {\n          frameID.current = requestAnimationFrame(animateScroll);\n        } else {\n          typeof onScrollFinish === \"function\" && onScrollFinish();\n          startTime.current = 0;\n          frameID.current = 0;\n          cancel();\n        }\n      }\n      animateScroll();\n    },\n    [axis, duration, easing, isList, offset, onScrollFinish, reducedMotion]\n  );\n  const handleStop = () => {\n    if (cancelable) {\n      shouldStop.current = true;\n    }\n  };\n  useWindowEvent(\"wheel\", handleStop, {\n    passive: true\n  });\n  useWindowEvent(\"touchmove\", handleStop, {\n    passive: true\n  });\n  useEffect18(() => cancel, []);\n  return {\n    scrollableRef,\n    targetRef,\n    scrollIntoView,\n    cancel\n  };\n}\n\n// src/use-resize-observer/use-resize-observer.ts\nimport { useEffect as useEffect19, useMemo as useMemo3, useRef as useRef15, useState as useState16 } from \"react\";\nvar defaultState = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0\n};\nfunction useResizeObserver() {\n  const frameID = useRef15(0);\n  const ref = useRef15(null);\n  const [rect, setRect] = useState16(defaultState);\n  const observer = useMemo3(\n    () => typeof window !== \"undefined\" ? new ResizeObserver((entries) => {\n      const entry = entries[0];\n      if (entry) {\n        cancelAnimationFrame(frameID.current);\n        frameID.current = requestAnimationFrame(() => {\n          if (ref.current) {\n            setRect(entry.contentRect);\n          }\n        });\n      }\n    }) : null,\n    []\n  );\n  useEffect19(() => {\n    if (ref.current) {\n      observer == null ? void 0 : observer.observe(ref.current);\n    }\n    return () => {\n      observer == null ? void 0 : observer.disconnect();\n      if (frameID.current) {\n        cancelAnimationFrame(frameID.current);\n      }\n    };\n  }, [ref.current]);\n  return [ref, rect];\n}\nfunction useElementSize() {\n  const [ref, { width, height }] = useResizeObserver();\n  return { ref, width, height };\n}\n\n// src/use-shallow-effect/use-shallow-effect.ts\nimport { useEffect as useEffect20, useRef as useRef16 } from \"react\";\nfunction shallowCompare(prevValue, currValue) {\n  if (!prevValue || !currValue) {\n    return false;\n  }\n  if (prevValue === currValue) {\n    return true;\n  }\n  if (prevValue.length !== currValue.length) {\n    return false;\n  }\n  for (let i = 0; i < prevValue.length; i += 1) {\n    if (!shallowEqual(prevValue[i], currValue[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction useShallowCompare(dependencies) {\n  const ref = useRef16([]);\n  const updateRef = useRef16(0);\n  if (!shallowCompare(ref.current, dependencies)) {\n    ref.current = dependencies;\n    updateRef.current += 1;\n  }\n  return [updateRef.current];\n}\nfunction useShallowEffect(cb, dependencies) {\n  useEffect20(cb, useShallowCompare(dependencies));\n}\n\n// src/use-toggle/use-toggle.ts\nimport { useReducer as useReducer2 } from \"react\";\nfunction useToggle(options = [false, true]) {\n  const [[option], toggle] = useReducer2((state, action) => {\n    const value = action instanceof Function ? action(state[0]) : action;\n    const index = Math.abs(state.indexOf(value));\n    return state.slice(index).concat(state.slice(0, index));\n  }, options);\n  return [option, toggle];\n}\n\n// src/use-viewport-size/use-viewport-size.ts\nimport { useCallback as useCallback7, useState as useState17, useEffect as useEffect21 } from \"react\";\nvar eventListerOptions = {\n  passive: true\n};\nfunction useViewportSize() {\n  const [windowSize, setWindowSize] = useState17({\n    width: 0,\n    height: 0\n  });\n  const setSize = useCallback7(() => {\n    setWindowSize({ width: window.innerWidth || 0, height: window.innerHeight || 0 });\n  }, []);\n  useWindowEvent(\"resize\", setSize, eventListerOptions);\n  useWindowEvent(\"orientationchange\", setSize, eventListerOptions);\n  useEffect21(setSize, []);\n  return windowSize;\n}\n\n// src/use-window-scroll/use-window-scroll.ts\nimport { useState as useState18, useEffect as useEffect22 } from \"react\";\nfunction getScrollPosition() {\n  return typeof window !== \"undefined\" ? { x: window.pageXOffset, y: window.pageYOffset } : { x: 0, y: 0 };\n}\nfunction scrollTo({ x, y }) {\n  if (typeof window !== \"undefined\") {\n    const scrollOptions = { behavior: \"smooth\" };\n    if (typeof x === \"number\") {\n      scrollOptions.left = x;\n    }\n    if (typeof y === \"number\") {\n      scrollOptions.top = y;\n    }\n    window.scrollTo(scrollOptions);\n  }\n}\nfunction useWindowScroll() {\n  const [position, setPosition] = useState18({ x: 0, y: 0 });\n  useWindowEvent(\"scroll\", () => setPosition(getScrollPosition()));\n  useWindowEvent(\"resize\", () => setPosition(getScrollPosition()));\n  useEffect22(() => {\n    setPosition(getScrollPosition());\n  }, []);\n  return [position, scrollTo];\n}\n\n// src/use-intersection/use-intersection.ts\nimport { useCallback as useCallback8, useRef as useRef17, useState as useState19 } from \"react\";\nfunction useIntersection(options) {\n  const [entry, setEntry] = useState19(null);\n  const observer = useRef17(null);\n  const ref = useCallback8(\n    (element) => {\n      if (observer.current) {\n        observer.current.disconnect();\n        observer.current = null;\n      }\n      if (element === null) {\n        setEntry(null);\n        return;\n      }\n      observer.current = new IntersectionObserver(([_entry]) => {\n        setEntry(_entry);\n      }, options);\n      observer.current.observe(element);\n    },\n    [options == null ? void 0 : options.rootMargin, options == null ? void 0 : options.root, options == null ? void 0 : options.threshold]\n  );\n  return { ref, entry };\n}\n\n// src/use-hash/use-hash.ts\nimport { useState as useState20, useEffect as useEffect23 } from \"react\";\nfunction useHash({\n  getInitialValueInEffect = false\n} = {}) {\n  const [hash, setHashValue] = useState20(\n    getInitialValueInEffect ? window.location.hash || \"\" : \"\"\n  );\n  const setHash = (value) => {\n    const valueWithHash = value.startsWith(\"#\") ? value : `#${value}`;\n    window.location.hash = valueWithHash;\n    setHashValue(valueWithHash);\n  };\n  useWindowEvent(\"hashchange\", () => {\n    const newHash = window.location.hash;\n    if (hash !== newHash) {\n      setHashValue(hash);\n    }\n  });\n  useEffect23(() => {\n    if (getInitialValueInEffect) {\n      setHashValue(window.location.hash);\n    }\n  }, []);\n  return [hash, setHash];\n}\n\n// src/use-hotkeys/use-hotkeys.ts\nimport { useEffect as useEffect24 } from \"react\";\n\n// src/use-hotkeys/parse-hotkey.ts\nfunction parseHotkey(hotkey) {\n  const keys = hotkey.toLowerCase().split(\"+\").map((part) => part.trim());\n  const modifiers = {\n    alt: keys.includes(\"alt\"),\n    ctrl: keys.includes(\"ctrl\"),\n    meta: keys.includes(\"meta\"),\n    mod: keys.includes(\"mod\"),\n    shift: keys.includes(\"shift\")\n  };\n  const reservedKeys = [\"alt\", \"ctrl\", \"meta\", \"shift\", \"mod\"];\n  const freeKey = keys.find((key) => !reservedKeys.includes(key));\n  return {\n    ...modifiers,\n    key: freeKey\n  };\n}\nfunction isExactHotkey(hotkey, event) {\n  const { alt, ctrl, meta, mod, shift, key } = hotkey;\n  const { altKey, ctrlKey, metaKey, shiftKey, key: pressedKey } = event;\n  if (alt !== altKey) {\n    return false;\n  }\n  if (mod) {\n    if (!ctrlKey && !metaKey) {\n      return false;\n    }\n  } else {\n    if (ctrl !== ctrlKey) {\n      return false;\n    }\n    if (meta !== metaKey) {\n      return false;\n    }\n  }\n  if (shift !== shiftKey) {\n    return false;\n  }\n  if (key && (pressedKey.toLowerCase() === key.toLowerCase() || event.code.replace(\"Key\", \"\").toLowerCase() === key.toLowerCase())) {\n    return true;\n  }\n  return false;\n}\nfunction getHotkeyMatcher(hotkey) {\n  return (event) => isExactHotkey(parseHotkey(hotkey), event);\n}\nfunction getHotkeyHandler(hotkeys) {\n  return (event) => {\n    const _event = \"nativeEvent\" in event ? event.nativeEvent : event;\n    hotkeys.forEach(([hotkey, handler, options = { preventDefault: true }]) => {\n      if (getHotkeyMatcher(hotkey)(_event)) {\n        if (options.preventDefault) {\n          event.preventDefault();\n        }\n        handler(_event);\n      }\n    });\n  };\n}\n\n// src/use-hotkeys/use-hotkeys.ts\nfunction shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable = false) {\n  if (event.target instanceof HTMLElement) {\n    if (triggerOnContentEditable) {\n      return !tagsToIgnore.includes(event.target.tagName);\n    }\n    return !event.target.isContentEditable && !tagsToIgnore.includes(event.target.tagName);\n  }\n  return true;\n}\nfunction useHotkeys(hotkeys, tagsToIgnore = [\"INPUT\", \"TEXTAREA\", \"SELECT\"], triggerOnContentEditable = false) {\n  useEffect24(() => {\n    const keydownListener = (event) => {\n      hotkeys.forEach(([hotkey, handler, options = { preventDefault: true }]) => {\n        if (getHotkeyMatcher(hotkey)(event) && shouldFireEvent(event, tagsToIgnore, triggerOnContentEditable)) {\n          if (options.preventDefault) {\n            event.preventDefault();\n          }\n          handler(event);\n        }\n      });\n    };\n    document.documentElement.addEventListener(\"keydown\", keydownListener);\n    return () => document.documentElement.removeEventListener(\"keydown\", keydownListener);\n  }, [hotkeys]);\n}\n\n// src/use-fullscreen/use-fullscreen.ts\nimport { useCallback as useCallback9, useRef as useRef18, useState as useState21, useEffect as useEffect25 } from \"react\";\nfunction getFullscreenElement() {\n  const _document = window.document;\n  const fullscreenElement = _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement;\n  return fullscreenElement;\n}\nasync function exitFullscreen() {\n  const _document = window.document;\n  if (typeof _document.exitFullscreen === \"function\")\n    return _document.exitFullscreen();\n  if (typeof _document.msExitFullscreen === \"function\")\n    return _document.msExitFullscreen();\n  if (typeof _document.webkitExitFullscreen === \"function\")\n    return _document.webkitExitFullscreen();\n  if (typeof _document.mozCancelFullScreen === \"function\")\n    return _document.mozCancelFullScreen();\n  return null;\n}\nasync function enterFullScreen(element) {\n  var _a, _b, _c, _d, _e;\n  const _element = element;\n  return ((_a = _element.requestFullscreen) == null ? void 0 : _a.call(_element)) || ((_b = _element.msRequestFullscreen) == null ? void 0 : _b.call(_element)) || ((_c = _element.webkitEnterFullscreen) == null ? void 0 : _c.call(_element)) || ((_d = _element.webkitRequestFullscreen) == null ? void 0 : _d.call(_element)) || ((_e = _element.mozRequestFullscreen) == null ? void 0 : _e.call(_element));\n}\nvar prefixes = [\"\", \"webkit\", \"moz\", \"ms\"];\nfunction addEvents(element, {\n  onFullScreen,\n  onError\n}) {\n  prefixes.forEach((prefix) => {\n    element.addEventListener(`${prefix}fullscreenchange`, onFullScreen);\n    element.addEventListener(`${prefix}fullscreenerror`, onError);\n  });\n  return () => {\n    prefixes.forEach((prefix) => {\n      element.removeEventListener(`${prefix}fullscreenchange`, onFullScreen);\n      element.removeEventListener(`${prefix}fullscreenerror`, onError);\n    });\n  };\n}\nfunction useFullscreen() {\n  const [fullscreen, setFullscreen] = useState21(false);\n  const _ref = useRef18();\n  const handleFullscreenChange = useCallback9(\n    (event) => {\n      setFullscreen(event.target === getFullscreenElement());\n    },\n    [setFullscreen]\n  );\n  const handleFullscreenError = useCallback9(\n    (event) => {\n      setFullscreen(false);\n      console.error(\n        `[@raikou/hooks] use-fullscreen: Error attempting full-screen mode method: ${event} (${event.target})`\n      );\n    },\n    [setFullscreen]\n  );\n  const toggle = useCallback9(async () => {\n    if (!getFullscreenElement()) {\n      await enterFullScreen(_ref.current);\n    } else {\n      await exitFullscreen();\n    }\n  }, []);\n  const ref = useCallback9((element) => {\n    if (element === null) {\n      _ref.current = window.document.documentElement;\n    } else {\n      _ref.current = element;\n    }\n  }, []);\n  useEffect25(() => {\n    if (!_ref.current && window.document) {\n      _ref.current = window.document.documentElement;\n      return addEvents(_ref.current, {\n        onFullScreen: handleFullscreenChange,\n        onError: handleFullscreenError\n      });\n    }\n    if (_ref.current) {\n      return addEvents(_ref.current, {\n        onFullScreen: handleFullscreenChange,\n        onError: handleFullscreenError\n      });\n    }\n    return void 0;\n  }, []);\n  return { ref, toggle, fullscreen };\n}\n\n// src/use-logger/use-logger.ts\nimport { useEffect as useEffect26 } from \"react\";\nfunction useLogger(componentName, props) {\n  useEffect26(() => {\n    console.log(`${componentName} mounted`, ...props);\n    return () => console.log(`${componentName} unmounted`);\n  }, []);\n  useDidUpdate(() => {\n    console.log(`${componentName} updated`, ...props);\n  }, props);\n  return null;\n}\n\n// src/use-hover/use-hover.ts\nimport { useState as useState22, useEffect as useEffect27, useRef as useRef19, useCallback as useCallback10 } from \"react\";\nfunction useHover() {\n  const [hovered, setHovered] = useState22(false);\n  const ref = useRef19(null);\n  const onMouseEnter = useCallback10(() => setHovered(true), []);\n  const onMouseLeave = useCallback10(() => setHovered(false), []);\n  useEffect27(() => {\n    if (ref.current) {\n      ref.current.addEventListener(\"mouseenter\", onMouseEnter);\n      ref.current.addEventListener(\"mouseleave\", onMouseLeave);\n      return () => {\n        var _a, _b;\n        (_a = ref.current) == null ? void 0 : _a.removeEventListener(\"mouseenter\", onMouseEnter);\n        (_b = ref.current) == null ? void 0 : _b.removeEventListener(\"mouseleave\", onMouseLeave);\n      };\n    }\n    return void 0;\n  }, []);\n  return { ref, hovered };\n}\n\n// src/use-validated-state/use-validated-state.ts\nimport { useState as useState23 } from \"react\";\nfunction useValidatedState(initialValue, validation, initialValidationState) {\n  const [value, setValue] = useState23(initialValue);\n  const [lastValidValue, setLastValidValue] = useState23(\n    validation(initialValue) ? initialValue : void 0\n  );\n  const [valid, setValid] = useState23(\n    typeof initialValidationState === \"boolean\" ? initialValidationState : validation(initialValue)\n  );\n  const onChange = (val) => {\n    if (validation(val)) {\n      setLastValidValue(val);\n      setValid(true);\n    } else {\n      setValid(false);\n    }\n    setValue(val);\n  };\n  return [{ value, lastValidValue, valid }, onChange];\n}\n\n// src/use-os/use-os.ts\nimport { useState as useState24 } from \"react\";\nfunction getOS() {\n  if (typeof window === \"undefined\") {\n    return \"undetermined\";\n  }\n  const { userAgent } = window.navigator;\n  const macosPlatforms = /(Macintosh)|(MacIntel)|(MacPPC)|(Mac68K)/i;\n  const windowsPlatforms = /(Win32)|(Win64)|(Windows)|(WinCE)/i;\n  const iosPlatforms = /(iPhone)|(iPad)|(iPod)/i;\n  if (macosPlatforms.test(userAgent)) {\n    return \"macos\";\n  }\n  if (iosPlatforms.test(userAgent)) {\n    return \"ios\";\n  }\n  if (windowsPlatforms.test(userAgent)) {\n    return \"windows\";\n  }\n  if (/Android/i.test(userAgent)) {\n    return \"android\";\n  }\n  if (/Linux/i.test(userAgent)) {\n    return \"linux\";\n  }\n  return \"undetermined\";\n}\nfunction useOs(options = { getValueInEffect: true }) {\n  const [value, setValue] = useState24(options.getValueInEffect ? \"undetermined\" : getOS());\n  useIsomorphicEffect(() => {\n    if (options.getValueInEffect) {\n      setValue(getOS);\n    }\n  }, []);\n  return value;\n}\n\n// src/use-set-state/use-set-state.ts\nimport { useState as useState25, useCallback as useCallback11 } from \"react\";\nfunction useSetState(initialState) {\n  const [state, _setState] = useState25(initialState);\n  const setState = useCallback11(\n    (statePartial) => _setState((current) => ({\n      ...current,\n      ...typeof statePartial === \"function\" ? statePartial(current) : statePartial\n    })),\n    []\n  );\n  return [state, setState];\n}\n\n// src/use-input-state/use-input-state.ts\nimport { useState as useState26 } from \"react\";\nfunction getInputOnChange(setValue) {\n  return (val) => {\n    if (!val) {\n      setValue(val);\n    } else if (typeof val === \"function\") {\n      setValue(val);\n    } else if (typeof val === \"object\" && \"nativeEvent\" in val) {\n      const { currentTarget } = val;\n      if (currentTarget.type === \"checkbox\") {\n        setValue(currentTarget.checked);\n      } else {\n        setValue(currentTarget.value);\n      }\n    } else {\n      setValue(val);\n    }\n  };\n}\nfunction useInputState(initialState) {\n  const [value, setValue] = useState26(initialState);\n  return [value, getInputOnChange(setValue)];\n}\n\n// src/use-event-listener/use-event-listener.ts\nimport { useRef as useRef20, useEffect as useEffect28 } from \"react\";\nfunction useEventListener(type, listener, options) {\n  const ref = useRef20();\n  useEffect28(() => {\n    if (ref.current) {\n      ref.current.addEventListener(type, listener, options);\n      return () => {\n        var _a;\n        return (_a = ref.current) == null ? void 0 : _a.removeEventListener(type, listener, options);\n      };\n    }\n    return void 0;\n  }, [listener, options]);\n  return ref;\n}\n\n// src/use-disclosure/use-disclosure.ts\nimport { useState as useState27, useCallback as useCallback12 } from \"react\";\nfunction useDisclosure(initialState = false, callbacks) {\n  const { onOpen, onClose } = callbacks || {};\n  const [opened, setOpened] = useState27(initialState);\n  const open = useCallback12(() => {\n    setOpened((isOpened) => {\n      if (!isOpened) {\n        onOpen == null ? void 0 : onOpen();\n        return true;\n      }\n      return isOpened;\n    });\n  }, [onOpen]);\n  const close = useCallback12(() => {\n    setOpened((isOpened) => {\n      if (isOpened) {\n        onClose == null ? void 0 : onClose();\n        return false;\n      }\n      return isOpened;\n    });\n  }, [onClose]);\n  const toggle = useCallback12(() => {\n    opened ? close() : open();\n  }, [close, open, opened]);\n  return [opened, { open, close, toggle }];\n}\n\n// src/use-focus-within/use-focus-within.ts\nimport { useRef as useRef21, useState as useState28, useEffect as useEffect29 } from \"react\";\nfunction containsRelatedTarget(event) {\n  if (event.currentTarget instanceof HTMLElement && event.relatedTarget instanceof HTMLElement) {\n    return event.currentTarget.contains(event.relatedTarget);\n  }\n  return false;\n}\nfunction useFocusWithin({\n  onBlur,\n  onFocus\n} = {}) {\n  const ref = useRef21();\n  const [focused, _setFocused] = useState28(false);\n  const focusedRef = useRef21(false);\n  const setFocused = (value) => {\n    _setFocused(value);\n    focusedRef.current = value;\n  };\n  const handleFocusIn = (event) => {\n    if (!focusedRef.current) {\n      setFocused(true);\n      onFocus == null ? void 0 : onFocus(event);\n    }\n  };\n  const handleFocusOut = (event) => {\n    if (focusedRef.current && !containsRelatedTarget(event)) {\n      setFocused(false);\n      onBlur == null ? void 0 : onBlur(event);\n    }\n  };\n  useEffect29(() => {\n    if (ref.current) {\n      ref.current.addEventListener(\"focusin\", handleFocusIn);\n      ref.current.addEventListener(\"focusout\", handleFocusOut);\n      return () => {\n        var _a, _b;\n        (_a = ref.current) == null ? void 0 : _a.removeEventListener(\"focusin\", handleFocusIn);\n        (_b = ref.current) == null ? void 0 : _b.removeEventListener(\"focusout\", handleFocusOut);\n      };\n    }\n    return void 0;\n  }, [handleFocusIn, handleFocusOut]);\n  return { ref, focused };\n}\n\n// src/use-network/use-network.ts\nimport { useState as useState29, useEffect as useEffect30, useCallback as useCallback13 } from \"react\";\nfunction getConnection() {\n  if (typeof navigator === \"undefined\") {\n    return {};\n  }\n  const _navigator = navigator;\n  const connection = _navigator.connection || _navigator.mozConnection || _navigator.webkitConnection;\n  if (!connection) {\n    return {};\n  }\n  return {\n    downlink: connection == null ? void 0 : connection.downlink,\n    downlinkMax: connection == null ? void 0 : connection.downlinkMax,\n    effectiveType: connection == null ? void 0 : connection.effectiveType,\n    rtt: connection == null ? void 0 : connection.rtt,\n    saveData: connection == null ? void 0 : connection.saveData,\n    type: connection == null ? void 0 : connection.type\n  };\n}\nfunction useNetwork() {\n  const [status, setStatus] = useState29({\n    online: true\n  });\n  const handleConnectionChange = useCallback13(\n    () => setStatus((current) => ({ ...current, ...getConnection() })),\n    []\n  );\n  useWindowEvent(\"online\", () => setStatus({ online: true, ...getConnection() }));\n  useWindowEvent(\"offline\", () => setStatus({ online: false, ...getConnection() }));\n  useEffect30(() => {\n    const _navigator = navigator;\n    if (_navigator.connection) {\n      setStatus({ online: _navigator.onLine, ...getConnection() });\n      _navigator.connection.addEventListener(\"change\", handleConnectionChange);\n      return () => _navigator.connection.removeEventListener(\"change\", handleConnectionChange);\n    }\n    return void 0;\n  }, []);\n  return status;\n}\n\n// src/use-timeout/use-timeout.ts\nimport { useRef as useRef22, useEffect as useEffect31, useCallback as useCallback14 } from \"react\";\nfunction useTimeout(callback, delay, options = { autoInvoke: false }) {\n  const timeoutRef = useRef22(null);\n  const start = useCallback14(\n    (...callbackParams) => {\n      if (!timeoutRef.current) {\n        timeoutRef.current = window.setTimeout(() => {\n          callback(callbackParams);\n          timeoutRef.current = null;\n        }, delay);\n      }\n    },\n    [delay]\n  );\n  const clear = useCallback14(() => {\n    if (timeoutRef.current) {\n      window.clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n  }, []);\n  useEffect31(() => {\n    if (options.autoInvoke) {\n      start();\n    }\n    return clear;\n  }, [clear, start]);\n  return { start, clear };\n}\n\n// src/use-text-selection/use-text-selection.ts\nimport { useState as useState30, useEffect as useEffect32 } from \"react\";\nfunction useTextSelection() {\n  const forceUpdate = useForceUpdate();\n  const [selection, setSelection] = useState30(null);\n  const handleSelectionChange = () => {\n    setSelection(document.getSelection());\n    forceUpdate();\n  };\n  useEffect32(() => {\n    setSelection(document.getSelection());\n    document.addEventListener(\"selectionchange\", handleSelectionChange);\n    return () => document.removeEventListener(\"selectionchange\", handleSelectionChange);\n  }, []);\n  return selection;\n}\n\n// src/use-previous/use-previous.ts\nimport { useEffect as useEffect33, useRef as useRef23 } from \"react\";\nfunction usePrevious(value) {\n  const ref = useRef23();\n  useEffect33(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\n// src/use-favicon/use-favicon.ts\nimport { useRef as useRef24 } from \"react\";\nvar MIME_TYPES = {\n  ico: \"image/x-icon\",\n  png: \"image/png\",\n  svg: \"image/svg+xml\",\n  gif: \"image/gif\"\n};\nfunction useFavicon(url) {\n  const link = useRef24();\n  useIsomorphicEffect(() => {\n    if (!url) {\n      return;\n    }\n    if (!link.current) {\n      const existingElements = document.querySelectorAll('link[rel*=\"icon\"]');\n      existingElements.forEach((element2) => document.head.removeChild(element2));\n      const element = document.createElement(\"link\");\n      element.rel = \"shortcut icon\";\n      link.current = element;\n      document.querySelector(\"head\").appendChild(element);\n    }\n    const splittedUrl = url.split(\".\");\n    link.current.setAttribute(\n      \"type\",\n      // @ts-ignore\n      MIME_TYPES[splittedUrl[splittedUrl.length - 1].toLowerCase()]\n    );\n    link.current.setAttribute(\"href\", url);\n  }, [url]);\n}\n\n// src/use-headroom/use-headroom.ts\nimport { useRef as useRef25 } from \"react\";\nvar isFixed = (current, fixedAt) => current <= fixedAt;\nvar isPinned = (current, previous) => current <= previous;\nvar isReleased = (current, previous, fixedAt) => !isPinned(current, previous) && !isFixed(current, fixedAt);\nfunction useHeadroom({\n  fixedAt = 0,\n  onPin,\n  onFix,\n  onRelease\n} = {}) {\n  const scrollRef = useRef25(0);\n  const [{ y: scrollPosition }] = useWindowScroll();\n  useIsomorphicEffect(() => {\n    if (isPinned(scrollPosition, scrollRef.current)) {\n      onPin == null ? void 0 : onPin();\n    }\n  }, [scrollPosition, onPin]);\n  useIsomorphicEffect(() => {\n    if (isFixed(scrollPosition, fixedAt)) {\n      onFix == null ? void 0 : onFix();\n    }\n  }, [scrollPosition, fixedAt, onFix]);\n  useIsomorphicEffect(() => {\n    if (isReleased(scrollPosition, scrollRef.current, fixedAt)) {\n      onRelease == null ? void 0 : onRelease();\n    }\n  }, [scrollPosition, onRelease]);\n  useIsomorphicEffect(() => {\n    scrollRef.current = window.scrollY;\n  }, [scrollPosition]);\n  if (isPinned(scrollPosition, scrollRef.current)) {\n    return true;\n  }\n  if (isFixed(scrollPosition, fixedAt)) {\n    return true;\n  }\n  return false;\n}\n\n// src/use-eye-dropper/use-eye-dropper.ts\nimport { useCallback as useCallback15, useState as useState31 } from \"react\";\nfunction useEyeDropper() {\n  const [supported, setSupported] = useState31(false);\n  useIsomorphicEffect(() => {\n    setSupported(typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  }, []);\n  const open = useCallback15(\n    (options = {}) => {\n      if (supported) {\n        const eyeDropper = new window.EyeDropper();\n        return eyeDropper.open(options);\n      }\n      return Promise.resolve(void 0);\n    },\n    [supported]\n  );\n  return { supported, open };\n}\nexport {\n  assignRef,\n  clamp,\n  clampUseMovePosition,\n  getHotkeyHandler,\n  lowerFirst,\n  mergeRefs,\n  randomId,\n  range,\n  shallowEqual,\n  upperFirst,\n  useCallbackRef,\n  useClickOutside,\n  useClipboard,\n  useColorScheme,\n  useCounter,\n  useDebounceCallback,\n  useDebouncedState,\n  useDebouncedValue,\n  useDidUpdate,\n  useDisclosure,\n  useDocumentTitle,\n  useDocumentVisibility,\n  useElementSize,\n  useEventListener,\n  useEyeDropper,\n  useFavicon,\n  useFocusReturn,\n  useFocusTrap,\n  useFocusWithin,\n  useForceUpdate,\n  useFullscreen,\n  useHash,\n  useHeadroom,\n  useHotkeys,\n  useHover,\n  useId,\n  useIdle,\n  useInputState,\n  useIntersection,\n  useInterval,\n  useIsomorphicEffect,\n  useListState,\n  useLocalStorage,\n  useLogger,\n  useMediaQuery,\n  useMergedRef,\n  useMouse,\n  useMove,\n  useNetwork,\n  useOs,\n  usePageLeave,\n  usePagination,\n  usePrevious,\n  useQueue,\n  useReducedMotion,\n  useResizeObserver,\n  useScrollIntoView,\n  useSessionStorage,\n  useSetState,\n  useShallowEffect,\n  useTextSelection,\n  useTimeout,\n  useToggle,\n  useUncontrolled,\n  useValidatedState,\n  useViewportSize,\n  useWindowEvent,\n  useWindowScroll\n};\n","import React from \"react\";\nimport { Portal, PortalProps } from \"./Portal\";\n\nexport interface OptionalPortalProps extends PortalProps {\n  /** Determines whether children should be rendered inside `<Portal />` */\n  withinPortal?: boolean;\n}\n\nexport function OptionalPortal({\n  withinPortal = true,\n  children,\n  ...others\n}: OptionalPortalProps) {\n  if (withinPortal) {\n    return <Portal {...others}>{children}</Portal>;\n  }\n\n  return <>{children}</>;\n}\n\nOptionalPortal.displayName = \"@raikou/core/OptionalPortal\";\n","import \"/Users/paul/development/src/github/raikou/packages/raikou/components/Affix/src/Affix.module.css\"; export default {\"root\":\"m-7f854edf\"}"],"mappings":"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","names":["import_react","import_core","import_react","import_react","useEffect7","React","React","import_react","React","defaultProps","React"]}